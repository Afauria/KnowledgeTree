# HTTP简介

Http（Hyper Text Transfer Protocol，超文本传输协议）：超文本指的是包含图片、视频、压缩包、超链接等。

例如HTML（HyperText Mark-up Language，超文本标记语言）就是一种超文本

## 无状态

无状态协议：

1. 优点：服务端不需要记忆状态，能够减轻负担。
2. 缺点：对于事务处理没有记忆能力，对于有关联的多个请求，难以进行控制。

解决：通过Cookie和通过Session会话保存状态

1. Cookie：客户端第一次请求时，服务端下发Cookie数据，客户端保存Cookie，后续请求带上Cookie，避免重复验证
2. Session：客户端第一次请求时，服务端为每个客户端创建Session，保存数据，并将Session ID以Cookie形式返回给客户端，客户端每次请求带着Session ID

Cookie和Session区别

1. Cookies数据保存在客户端，可以减轻服务器压力。Session数据保存在服务端，占用服务器资源
2. Cookies在本地可以修改、删除、禁用。Session安全一点。
3. Cookie大小有限，最大为4KB

## 不安全

1. 明文传输，数据没有加密，内容会被**窃听**，例如账号信息泄漏
2. 无法验证报文完整性，内容会被**篡改**，例如植入了垃圾广告
3. 不验证通信方身份，可能遭遇**伪装（冒充）**，例如访问到假的网站

解决：使用HTTPS

# 浏览器请求过程

1. 浏览器输入url。先解析url地址是否合法
2. 浏览器检查是否有缓存（浏览器缓存-系统缓存-路由器缓存）。如果有，直接显示。如果没有，跳到第三步。
3. 在发送http请求前，需要域名解析（DNS解析），解析获取对应过的ip地址。
4. 浏览器向服务器发起tcp连接，三次握手
5. 握手成功后，浏览器向服务器发送http请求，请求数据包
6. 服务器收到处理的请求，将数据返回至浏览器
7. 浏览器收到http响应。
8. 浏览器解析响应。如果响应可以缓存，则存入缓存
9. 浏览器发送请求获取嵌入在HTML中的资源（html，css，JavaScript，图片，音乐等），对于未知类型，会弹出对话框
10. 浏览器发送异步请求
11. 页面全部渲染结束

Http请求过程

1. 建立TCP连接
2. 客户端发送请求行，例如GET
3. 客户端发送请求头，以空白行结尾
4. 服务器发送状态行：例如协议版本号，响应状态码
5. 服务器发送响应头
6. 服务器发送响应数据，以空白行结尾
7. 断开TCP连接

# 请求方式

GET：参数在URL中，只支持ASCII字符

POST：参数在Body中，数据可以是任意格式

1. POST请求URL中也可以有参数
2. GET也可以在Body中携带数据
3. 请求安全（服务器数据不会被修改）和幂等（多次调用结果相同）
   1. GET语义是只读，不修改服务器数据，因此是安全和幂等
   2. POST可能会增、删、改服务器数据，因此是不安全和非幂等的
   3. 实际情况中，开发者不一定按照要求实现，GET也可以修改数据，POST不修改数据
4. 从通信安全上看，GET和POST都是明文请求，都可以被截获

# HTTP状态码

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

`2xx` 类状态码表示服务器**成功**处理了客户端的请求

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

`3xx` 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

# 版本差异

## Http/0.9（1991年）

没有Header，只支持GET请求

## Http/1.0（1996年）

1. 引入Header概念，让HTTP请求和响应更加灵活，将元数据和头信息分离
2. 请求头引入了Http/1.0协议版本号
3. 支持GET、POST、HEAD请求
4. 传输的数据不再仅限于文本
5. 增加了响应状态码（Status Code），标记可能的错误原因
   1. 1xx消息响应
   2. 2xx成功响应
   3. 3xx重定向
   4. 4xx客户端错误
   5. 5xx服务器错误
6. Content-Type传输其他类型文件，例如图像、视频、二进制文件
7. **一个TCP连接只能发送一次请求，每次请求都需要重新建立TCP连接。**（可以使用Connection非标准字段，由于不是标准，实现不统一）

## Http/1.1（1997年）

1. 实现**长连接**（默认`Connection: keep-alive`），即TCP连接默认不关闭，**允许多次请求重用TCP连接**，必须串行发送，要并发的话需要建立多个TCP连接，浏览器限制一个Host只能建立6个TCP连接
2. **支持Pipeline传输，一个TCP连接中，客户端可以发出多个请求，不需要等服务端响应**，解决了请求的队头阻塞，但没有解决响应的队头阻塞，需要根据请求的先后顺序响应。
3. 允许响应数据分块（chunked），实现**断点续传**
4. 支持PUT、DELETE、PATCH（更新某些字段）、OPTIONS（检查请求方式）请求
5. 请求头新增Host字段，让服务端知道用户请求的是哪个域名，用来处理服务器存在多个虚拟主机的情况。
6. 头信息是二进制，数据可以是文本，也可以是二进制
7. 提供身份认证机制，许多web站点要求用户提供一个用户名—口令对才能访问存放在其服务器中的文档，这种要求称为身份认证(authentication)。HTTP提供特殊的状态码和头部来帮助Web站点执行身份认证。
8. 新增Type、Language、Encoding等字段

Http/1.1（2014年）：

1. 增加了TLS支持，即https传输
2. 支持四种模型：
   1.  短连接
   2. 可重用TCP的长连接
   3. 服务端push模型（服务端主动将数据推送到客户端cache中）
   4. WebSocket模型

## Http/2.0（2015年）

1. **二进制分帧**：全部以二进制格式传输，不再是纯文本，解析更加高效，一个消息由一个或多个帧组成
2. **IO多路复用**，双工：
   1. 同域名下所有通信在一个连接上完成，支持并发多个请求。不需要建立多个TCP连接，每个数据包标记自身属于哪个流。
   2. 不用按顺序响应，而是在接收端重组，解决队头阻塞问题
3. **允许服务器主动向客户端推送数据，一次客户端请求，服务端可以多次响应**。客户端请求HTTP2.0的Web Server时，服务器会顺便把一些客户端需要的资源一起推送到客户端，避免客户端多次发出请求。客户端已缓存的话可以选择拒收，适合加载静态资源
4. **头信息压缩机制**（HPACK格式），减少数据传输量：
   1. 头信息使用gzip或compress压缩后再发送
   2. 客户端和服务器同时维护一张头信息表（头部键-值），所有字段都会存入这个表，生成一个索引号，后续只发索引号。新的首部会替换或追加字段
5. 默认要求HTTPS

> 帧：通信的最小单位，一个消息由一个或多个帧组成
>
> 流：每个请求和响应的所有数据包，是一个虚拟的通道，承载双向消息，每个流有一个唯一的整数ID

* TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，
* HTTP复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理。

## Http/3.0

Http2.0只解决了Http的队头阻塞，没有解决TCP的队头阻塞

Http3.0使用UDP，重新实现了一套可靠传输协议（QUIC）

# 断点续传的原理

Range:用于客户端到服务端的请求，可以通过改字段指定下载文件的某一段大小及其单位，字节偏移从0开始。典型格式：

Ranges: (unit=first byte pos)-[last byte pos]

Ranges: bytes=4000- 下载从第4000字节开始到文件结束部分

Ranges: bytes=0~N 下载第0-N字节范围的内容

Ranges: bytes=M-N 下载第M－N字节范围的内容

Ranges: bytes=-N 下载最后N字节内容

If-Range:用于客户端到服务端的请求，用于判断实体是否发生改变，必须与Range配合使用。若实体未被修改，则响应所缺少的那部分；否则，响应整个新的实体。

Accept-Ranges:用于server到client的应答，client通过该自段判断server是否支持断点续传。

Accept-Ranges:bytes 表示支持以bytes为单位进行传输。

Accept-Ranges:none 表示不支持断点续传

Content-Ranges:用于sever到client的应答，与Accept-Ranges在同一个报文内，通过该字段指定了返回的文件资源的字节范围。格式如下：

Content-Ranges:bytes M-N/size 大小为size的文件的第M－N字节范围的内容

https://mp.weixin.qq.com/s/fvvnQ3xI1nz-Ri3vBfG2lwhu

https://www.jianshu.com/p/7b91778158da

https://blog.csdn.net/xiaoming100001/article/details/81109617

- **内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。**
- **压缩：将文本数据进行压缩，减少带宽**
- **SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速**
- **TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。**



# HttpDNS

## 传统DNS过程

1. 检查浏览器中是否有域名缓存
2. 检查操作系统中是否有域名缓存：可以修改host文件
3. 向网络配置中的本地运营商DNS（LocalDNS）发出请求
4. LocalDNS没有的话会向根域名服务器请求解析，返回对应的顶级域名服务器的地址
5. LocalDNS请求顶级域名服务器，返回对应的二级域名服务器
6. LocalDNS请求二级域名服务器，查询DNS记录表，返回IP地址和DNS的TTL值
7. LocalDNS根据TTL值缓存IP地址，返回给客户端系统，客户端系统根据TTL值缓存再本地缓存中

## HttpDNS

直接向HttpDNS服务器IP进行请求，返回对应的IP地址。通常由服务端自行部署

优点：

1. 防止DNS劫持
2. 避免DNS搜索和解析，提高响应速度
3. 服务器可以自行对IP地址排序，降低连接失败率

使用场景

1. 对首屏时延要求比较高的APP或者网页；
2. 希望降低访问延迟、减少跨网访问的资讯、游戏类APP；
3. 希望降低连接失败率，提升业务成功率的通用APP；
4. 域名屡次被劫持，希望用户访问顺畅无阻的APP；



https://wjrsbu.smartapps.cn/zhihu/article?id=380524458&isShared=1&_swebfr=1&_swebFromHost=baiduboxapp

> TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4报头的一个8 bit字段。
>
> 注意：TTL与DNS TTL有区别。二者都是生存时间，前者指ICMP包的转发次数（跳数），后者指域名解析信息在DNS中的存在时间。
