什么是Http协议无状态协议？怎么解决Http协议无状态协议？

> 无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。状态协议解决办法：通过1、Cookie 2、通过Session会话保存。
>
> 1. cookies数据保存在客户端。session数据保存在服务端
> 2. cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗
> 3. session安全一点，但是占用服务器资源。

# 浏览器请求过程

1. 浏览器输入url。先解析url地址是否合法
2. 浏览器检查是否有缓存（浏览器缓存-系统缓存-路由器缓存）。如果有，直接显示。如果没有，跳到第三步。
3. 在发送http请求前，需要域名解析（DNS解析），解析获取对应过的ip地址。
4. 浏览器向服务器发起tcp连接，三次握手
5. 握手成功后，浏览器向服务器发送http请求，请求数据包
6. 服务器收到处理的请求，将数据返回至浏览器
7. 浏览器收到http响应。
8. 浏览器解析响应。如果响应可以缓存，则存入缓存
9. 浏览器发送请求获取嵌入在HTML中的资源（html，css，JavaScript，图片，音乐等），对于未知类型，会弹出对话框
10. 浏览器发送异步请求
11. 页面全部渲染结束

Http请求过程

1. 建立TCP连接
2. 客户端发送请求行，例如GET
3. 客户端发送请求头，以空白行结尾
4. 服务器发送状态行：例如协议版本号，响应状态码
5. 服务器发送响应头
6. 服务器发送响应数据，以空白行结尾
7. 断开TCP连接

# 版本差异

Http（Hyper Text Transfer Protocol，超文本传输协议）

## Http/0.9（1991年）

没有Header，只支持GET请求

## Http/1.0（1996年）

1. 引入Header概念，让HTTP请求和响应更加灵活，将元数据和头信息分离
2. 请求头引入了Http/1.0协议版本号
3. 支持GET、POST、HEAD请求
4. 传输的数据不再仅限于文本
5. 增加了响应状态码（Status Code），标记可能的错误原因
   1. 1xx消息响应
   2. 2xx成功响应
   3. 3xx重定向
   4. 4xx客户端错误
   5. 5xx服务器错误
6. Content-Type传输其他类型文件，例如图像、视频、二进制文件
7. **一个TCP连接只能发送一次请求，每次请求都需要重新建立TCP连接。**（可以使用Connection非标准字段，由于不是标准，实现不统一）

## Http/1.1（1997年）

1. 实现长连接（默认`Connection: keep-alive`），即TCP连接默认不关闭，**允许多次请求重用TCP连接**，必须串行发送，要并发的话需要建立多个TCP连接，浏览器限制一个Host只能建立6个TCP连接
2. **支持Pipeline传输，一个TCP连接中，客户端可以发出多个请求，不需要等服务端响应**，但服务端还是会阻塞，需要根据请求的先后顺序响应，容易造成队头阻塞。
3. 允许响应数据分块（chunked），实现**断点续传**
4. 支持PUT、DELETE、PATCH（更新某些字段）、OPTIONS（检查请求方式）请求
5. 请求头新增Host字段，让服务端知道用户请求的是哪个域名，用来处理服务器存在多个虚拟主机的情况。
6. 头信息是二进制，数据可以是文本，也可以是二进制
7. 提供身份认证机制，许多web站点要求用户提供一个用户名—口令对才能访问存放在其服务器中的文档，这种要求称为身份认证(authentication)。HTTP提供特殊的状态码和头部来帮助Web站点执行身份认证。
8. 新增Type、Language、Encoding等字段

Http/1.1（2014年）：

1. 增加了TLS支持，即https传输
2. 支持四种模型：
   1.  短连接
   2. 可重用TCP的长连接
   3. 服务端push模型（服务端主动将数据推送到客户端cache中）
   4. WebSocket模型

## Http/2.0（2015年）

1. **二进制分帧**：全部以二进制格式传输，不再是纯文本，解析更加高效，一个消息由一个或多个帧组成
2. **IO多路复用**，双工：
   1. 同域名下所有通信在一个连接上完成，支持并发多个请求。不需要建立多个TCP连接，每个数据包标记自身属于哪个流。
   2. 不用按顺序响应，而是在接收端重组，解决队头阻塞问题
3. **允许服务器主动向客户端推送数据，一次客户端请求，服务端可以多次响应**。客户端请求HTTP2.0的Web Server时，服务器会顺便把一些客户端需要的资源一起推送到客户端，避免客户端多次发出请求。客户端已缓存的话可以选择拒收，适合加载静态资源
4. **头信息压缩机制**（HPACK格式），减少数据传输量：
   1. 头信息使用gzip或compress压缩后再发送
   2. 客户端和服务器同时维护一张头信息表（头部键-值），所有字段都会存入这个表，生成一个索引号，后续只发索引号。新的首部会替换或追加字段
5. 默认要求HTTPS

> 帧：通信的最小单位，一个消息由一个或多个帧组成
>
> 流：每个请求和响应的所有数据包，是一个虚拟的通道，承载双向消息，每个流有一个唯一的整数ID

* TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，
* HTTP复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理。

## Http/3.0：

Http2.0只解决了Http的队头阻塞，没有解决TCP的队头阻塞

Http3.0使用UDP，重新实现了一套可靠传输协议





# HTTPS

1. 客户端发出请求，并带上随机数1，和客户端支持的加密算法
2. 服务端返回随机数2和匹配的加密算法
3. 服务端发送数字证书
4. 客户端解析数字证书，检查公钥机构、日期等，
5. 客户端生成随机数秘钥，和随机值1、2一起组装成会话秘钥，使用公钥加密，发给服务端
6. 服务端使用私钥解密获得秘钥和随机值1、2，组装会话秘钥
7. 客户端通信通过会话秘钥加密消息，验证服务端是否能正常接收
8. 服务端同样返回加密消息，如果客户端能够接收，则表示SSL连接建立

https://blog.csdn.net/xiaoming100001/article/details/81109617

- **内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。**
- **压缩：将文本数据进行压缩，减少带宽**
- **SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速**
- **TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。**

# 断点续传的原理

Range:用于客户端到服务端的请求，可以通过改字段指定下载文件的某一段大小及其单位，字节偏移从0开始。典型格式：

Ranges: (unit=first byte pos)-[last byte pos]

Ranges: bytes=4000- 下载从第4000字节开始到文件结束部分

Ranges: bytes=0~N 下载第0-N字节范围的内容

Ranges: bytes=M-N 下载第M－N字节范围的内容

Ranges: bytes=-N 下载最后N字节内容

If-Range:用于客户端到服务端的请求，用于判断实体是否发生改变，必须与Range配合使用。若实体未被修改，则响应所缺少的那部分；否则，响应整个新的实体。

Accept-Ranges:用于server到client的应答，client通过该自段判断server是否支持断点续传。

Accept-Ranges:bytes 表示支持以bytes为单位进行传输。

Accept-Ranges:none 表示不支持断点续传

Content-Ranges:用于sever到client的应答，与Accept-Ranges在同一个报文内，通过该字段指定了返回的文件资源的字节范围。格式如下：

Content-Ranges:bytes M-N/size 大小为size的文件的第M－N字节范围的内容



https://www.jianshu.com/p/7b91778158da
