# 不容错过的设计模式

深究设计模式，包含各种关于设计模式你不知道的细节。

GoF（Gang of Four，四人帮）总结了23种常用的设计模式，这是基于具体场景提出的解决方案，然而实际场景远远不止23种，因此我们看到的大多数代码都不会是标准的类图，而是使用基于这23种设计模式衍生出的变种。

在学习过程中，我们会发现设计模式存在一些规律或者法则，以下是自己的一些理解：

1. 不同模式之间只看类图的话存在很大的相似性：例如代理、适配器、装饰者核心实现都是通过组合对原来的类进行包装。门面模式和中介者模式都是通过组合多个对象，实现类与类之间的隔离。

   > 说到底类与类之间的关系简单来说无非就几种：继承（父子类）、实现（接口）、组合（成员变量）、依赖（方法参数）。而设计模式就是灵活运用和搭配这些关系，以实现软件的高内聚、低耦合。
   >
   > 不同的是设计模式的出发点、使用场景、解决的问题存在差异。

2. 大部分情况下使用组合都是面向接口或者抽象的，满足面向接口原则：例如代理、适配器等

   > 面向接口总结来讲无非就几大作用：
   >
   > 1. 用于约束和强制子类实现，定义一个行为规范
   > 2. 利用多态提高扩展性，可随时替换具体实现
   > 3. 对外隐藏细节，外部只知道接口，不知道具体实现

3. 设计模式不是死的，而是一种思想。大部分时候不会照搬设计模式的标准类图，而是使用它们的变种。例如

   > 1. 观察者模式：类图里面Subject对象需要维持一个观察者列表，实际使用中一般不需要用到列表。（如View事件监听）
   > 2. 策略模式：类图里面包含一个Context对象，实际使用中也可以不用，直接Client创建不同策略对象并调用。简单理解就是多态。
   > 3. 访问者模式：可以不定义抽象元素和具体元素，不重载接口方法，也可以不把元素放到列表中。只要满足对象结构接收访问者对象，并且在对象结构内部完成对子元素的遍历或访问，提供给访问者即可。目的是对外屏蔽访问规则和细节，例如内部可以遍历访问、递归访问、前序、后序访问等，访问者只需要接收到元素进行处理即可。
   > 4. 大部分模式砍掉类图中的接口之后，其实本质还是没有改变，明确接口的目的和意义。例如
   >    1. 代理是为了解决两个类之间无法直接通信的问题，并且代理类可以增加一些自己的行为（例如网络通信中的nginx代理，代理调用RPC服务等）。去掉接口之后还是能够达到这个目的，只不过缺少了对代理类的强制约束（要求代理类代理所有接口方法），并且没法使用Java的动态代理而已。
   >    2. 例如责任链模式，只要能够将多个对象串起来，并不一定要继承接口或抽象类

4. 设计模式记忆方法：通过名称去理解，类比现实生活，思考各个模式的场景和出发点。如代理、中介者、适配器、观察者、门面、命令、迭代器、责任链、工厂等。类图只是其形，并不需要照搬，理解了名称之后才能理解其背后的思想，灵活变通。

   > 学习过程中可以多问自己为什么？如果不怎么做会产生什么问题？是否可以去掉某个部分？再尝试”自圆其说“，思考理由是什么。

5. 设计原则不止针对类，可以小到一个方法、接口，也可以大到包、模块层面。实际编码过程中要灵活运用。设计模式也一样，多从宏观和微观的角度考虑。
