# 面向对象基本原则

SOLID原则+迪米特法则：

* 单一职责（SRP，Single-Responsibility Principle）：一个类只做一件核心的事，只有一个引起它变化的原因
* 开闭原则（OCP，Open-Closed Principle）：对扩展开放，对修改关闭
* 里氏替换原则（LSP，Liskov-Substitution Principle）：任何使用父类的地方，都能够被其子类替换，并且不影响程序运行结果。
* 接口隔离原则（ISP，Interface-Segregation Principle）：将臃肿庞大的接口拆分成多个专门的小接口，让接口只包含客户感兴趣的方法。
* 依赖倒置原则（DIP，Dependency-Inversion Principle）：高层模块不依赖于底层模块，二者都依赖于抽象。抽象不应该依赖具体，具体依赖于抽象
* 迪米特法则（LoD，Law of Demeter）：也叫做最少知识原则。一个对象对其他对象应当尽可能少的了解。

> Tips：设计原则不止针对类，可以小到一个方法、接口，也可以大到包、模块层面。实际编码过程中要灵活运用

## 单一职责

一个类只做一件核心的事，只有一个引起它变化的原因。

优点：

* 降低类的复杂度，避免类臃肿。外部使用的时候不需要包含冗余代码
* 提高可读性。
* 易于维护，易于发现和修复问题
* 降低修改问题的风险：只有一个职责，修改不会对其他功能造成影响

## 开闭原则

对扩展开放，对修改关闭：新增功能的时候尽量不修改原有逻辑，而是提供扩展方法。

优点：

* 利于测试：测试只需要针对扩展的代码测试，原有的代码没有变更
* 稳定性高：原有代码没有修改
* 易于维护和扩展：如下案例

实现方式：抽象约束，封装变化。即定义一个相对稳定的抽象层，将可变的因素封装在具体的实现类中。

具体案例：Java推荐的getter和setter写法。

属性直接设为public，如下，多处地方使用了该属性

```java
public class User {
  public String birthDay; //生日格式为yyyy-mm-dd
}
public class Main {
    public void test1(User user) {
        System.out.println(user.birthDay); //打印生日
    }
    public void test2(User user) {
        System.out.println(user.birthDay); //打印生日
    }
}
```

如果需求变更，需要修改日期格式为`x年x月x日`，需要修改多处代码，不符合开闭原则。

因此更合理的做法是提供getter方法，外部通过getter获取属性，当需求变更时，只需要修改getter方法，不需要修改其他地方。即**对修改关闭、对扩展开放**。

```java
public class User {
  private String birthDay;
  public String getBirthDay() {
      return new SimpleDateFormat("yyyy-mm-dd").format(birthDay);
      //return new SimpleDateFormat("年-月-日").format(birthDay);
  }
}
```

## 里氏替换原则

任何使用父类的地方，都能够被其子类替换，并且不影响程序运行结果。即**子类设计要兼容父类**。

原则：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类已有的方法。

作用：保证扩展父类的时候不会给已有系统引入新的错误。克服重写父类方法导致父类代码可复用性变差的缺点

具体实现方式如下：

1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
2. 子类中可以增加自己特有的方法：很明显，这种方式不会对父类造成影响
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
4. 当子类的方法实现父类的方法时（重写、重载或实现抽象方法），方法的后置条件（即方法的的返回值、抛出异常）要比父类的方法更严格或相等

如何理解不能覆盖父类非抽象方法？

例如：鸵鸟不是鸟，重写父类getFlySpeed方法，使用Ostrich类替换Bird类，产生异常

```java
class Bird { //鸟类
    int flySpeed;
    void setFlySpeed(int speed) {
        flySpeed = speed;
    }
    int getFlySpeed() {
        return flySpeed;
    }
}
class Ostrich extends Bird { //鸵鸟类
    @Override
    int getFlySpeed() {
        return 0; //由于鸵鸟不会飞，因此重写方法，返回0
    }
}
public class Main {
    public static void main(String[] args) {
        Bird bird1 = new Bird();
        Bird bird2 = new Ostrich();
        bird1.setFlySpeed(100);
        bird2.setFlySpeed(100);
        //计算飞行200公里需要的时间
        int time1 = 200 / bird1.getFlySpeed(); //计算正确
        int time2 = 200 / bird2.getFlySpeed(); //由于速度为0，出现除零异常。无法替换父类，不满足里氏替换原则。
    }
}
```

如何理解重载父类方法时，参数更宽松？（参数变了，所以一定是重载）

还是以鸟为例：可以看到子类参数比父类更严格时，不满足里氏替换原则

```java
class Bird { //鸟类
    void speak(CharSequence str) {//说话
        System.out.println("bird speak: "+str);
    }
    void sing(String str) {//唱歌
        System.out.println("bird sing: "+str);
    }
}
class Ostrich extends Bird { //鸵鸟类
    void speak(String str) { //重载方法参数比父类更严格
        System.out.println("ostrich speak: "+str);
    }
    void sing(CharSequence str) { //重载方法参数比父类更宽松
        System.out.println("bird sing: "+str);
    }
}
public class Main {
    public static void main(String[] args) {
        Bird bird1 = new Bird();
        Ostrich bird2 = new Ostrich(); //替换为鸵鸟类
        bird1.speak("Hello World"); // 输出bird speak：Hello World
        bird2.speak("Hello World"); // 输出ostrich speak：Hello World，无法替换父类，不满足里氏替换原则
        bird1.sing("Hello World"); // 输出bird sing：Hello World
        bird2.sing("Hello World"); // 输出bird sing：Hello World，可以替换父类，满足里氏替换原则
    }
}
```

如何理解实现父类方法时，返回值和异常比父类更严格？

> 这一点其实Java编译器已经帮我们限制了，重写时返回值和异常范围不能比父类大（即类型需要更具体），否则会编译不通过。

假设没有限制会怎么样？

还是以鸟为例：可以看到即使没有编译错误，运行的时候也会出现Object转CharSequence异常

```java
class Bird { //鸟类
    CharSequence getName() { //名称
        return "bird";
    }
    CharSequence getType() { //品种
        return "bird";
    }
    void speak() throws IOException {}
}
class Ostrich extends Bird { //鸵鸟类
    String getName() {
        return "ostrich";
    }
    Object getType() { //这里实际上会编译错误，假设没有编译错误，运行时会怎么样呢？
        return "ostrich";
    }
    void speak() throws Exception {} //这里实际会编译错误，子类不能抛出更大范围的异常。假设没有编译错误，运行时会怎么样呢？
}
public class Main {
    public static void main(String[] args) {
        Bird bird1 = new Bird();
        Ostrich bird2 = new Ostrich();
        CharSequence name1 = bird1.getName();
        CharSequence name2 = bird2.getName();
        
        CharSequence type1 = bird1.getType();
        CharSequence type2 = bird2.getType(); //编译错误。如果没有编译错误，真正运行的时候会出现类型转换失败，Object无法自动向下转型。
        //此处子类无法替换父类，不满足里氏替换原则
        
        try {
            bird1.speak();
            bird2.speak(); //编译错误。如果没有编译错误，真正运行的时候抛出Exception异常，无法被IOException捕获。
            //此处子类无法替换父类，不满足里氏替换原则
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

为什么编译器不强制限制参数更加宽松，只限制后置条件更加严格？

> 因为后置条件不限制的话在运行时会产生异常崩溃。
>
> 而前置条件不限制的话在运行时不会崩溃，只是单纯的不满足里氏替换原则而已，当然可能会造成逻辑错误。

### 协变与逆变

* 协变：指继承关系中，父类和子类构造出来的复杂类型之间，子类中重写方法的类型和父类方法的类型之间，也是父子类型的关系。
* 逆变：逆转了父类和子类间的关系
* 不变：既不是协变，也不是逆变。

如何理解协变和逆变这个说法？

> A和B是父子继承关系，A衍生出一个a类型，B衍生出来一个b类型，a和b仍然保持父子继承的关系。即协同改变，不改变原有关系
>
> 逆变则是b变成了a的父类

Java中数组是协变的：如下，Integer[]是Number[]的子类型。

```java
Number[] a = new Integer[10]; //编译通过
Integer[] b = new Number[10]; //编译错误
```

Java中泛型的协变和逆变

```java
ArrayList<Number> list1 = new ArrayList<Integer>(); //编译错误，ArrayList<Number>和ArrayList<Integer>不具有继承关系（不变）
List<Number> list2 = new ArrayList<Number>(); //编译通过，ArrayList<Number>是List<Number>的子类型（协变）
List<? extends Number> list3 = new ArrayList<Integer>(); //编译通过，ArrayList<Integer>()是List<? extends Number>的子类型（协变）
List<? super String> list = new ArrayList<Object>();//编译通过，ArrayList<Object>是List<? super String>的子类型（String和Object关系颠倒，逆变）
```

Java中重写方法的协变和逆变：

1. 前置条件更宽松：即重写方法的参数更宽松，范围更大。（逆变，编译器没限制，是里氏替换原则的要求）
2. 后置条件更严格：即重写方法的返回值、异常类型更严格，范围更小。（协变，编译器有限制）

```java
class A {
    Object a() throws IOException {
        return "";
    }
}
class B extends A{
    @Override
    String a() {
        return "";
    }
}
//可以编译通过，子类返回值、抛出异常范围比父类更小，依然保持父子类型的关系，即协变
```

## 接口隔离原则

将臃肿庞大的接口拆分成多个专门的小接口，让接口只包含客户感兴趣的方法。

接口隔离和单一职责都是对功能进行拆分，提高类的内聚性，体现了封装的思想，但两者侧重点不一样：

1. 单一职责注重的是对功能的拆分；接口隔离注重的是对接口依赖的隔离，避免依赖和实现不需要的接口方法
2. 单一职责用来约束类定义，针对类中的实现细节；接口隔离用来约束接口定义，针对抽象和程序整体框架的搭建

优点：

1. 提高接口的复用性，提高系统的灵活性
2. 提高内聚性，避免和外部有过多的交互
3. 避免子类实现不必要的方法，额外增多冗余代码：例如Android动画类：`onAnimationStart、onAnimationEnd、onAnimationCancel`等
4. 能够体现对象的层次，通过接口的继承，可以组装不同的接口，定义总接口

如果接口定义太小会造成接口数量过多，使设计复杂；如果定义太大，会降低灵活性，无法提供定制服务

## 依赖倒置原则

高层模块不依赖于底层模块，二者都依赖于抽象。抽象不应该依赖具体，具体依赖于抽象

## 迪米特法则



## 合成复用原则



# 其他原则

高内聚、低耦合：是软件设计的目标，评判好坏的标准。尽可能让一个方法（类、模块）只做一件事，减少类内部方法间（类与类之间、模块与模块之间）的交互复杂度。

面向接口编程：模块与模块之间尽可能使用接口通信，隐藏实现细节

多用接口，少用继承：继承关系比实现关系更紧密。由于接口不包含实现，外部无法知道实现细节。

多组合、少继承：组合关系耦合度更低，可以随时移除和替换，继承关系父类修改会影响子类

多封闭，少开放：除非必要，对外尽可能少暴露方法和属性，避免外部随意修改内部状态。能用private就不用public

少用全局变量：所有地方都可以修改全局变量，不安全，同时需要考虑状态同步。

尽量不用硬编码：硬编码代表无法动态替换实现，需要直接修改，违背开闭原则。

https://blog.csdn.net/qq_38969070/article/details/80733239

https://blog.csdn.net/rocketeerli/article/details/81585705

https://yearn.xyz/posts/techs/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/

http://c.biancheng.net/view/1322.html
