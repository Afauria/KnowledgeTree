---
layout: post
title: 面向对象
date: 2018-12-21
description: Java基础之面向对象
categories: Java
tags: 
- Java
---

# 面向对象和面向过程

* 面向过程（Procedure Oriented）：把问题分解成一个个步骤，按照步骤调用函数。
  * 自上而下，先定好函数入口，再逐步实现用到的方法
  * 一个类具备各种各样的功能。
  * 代码重用性低、扩展能力差，后期维护困难，代码耦合高。
* 面向对象（Object Oriented）：把属性、行为封装成对象，对同类对象提取共性，形成类，通过不同对象之间的组合、调用解决问题。
  * 自下而上，先设计组件，再通过对象间组合、调用，完成业务逻辑。
  * 每个类只负责自己的属性和功能。
  * 性能比面向过程低

# 三大特性

## 封装、继承、多态

* 封装：对客观事物进行抽象。将对象的属性和行为封装成一个类，并可以设置属性和方法对外的可见性。
  * 类描述了一类事物的状态和行为。如：把人抽象成一个类，有四肢、五官，可以说话、走路
  * 类是对象的抽象，对象是类的具体。类可以看作是对象的模板，一个类可以有多个对象。如：人是一个类，一个人是具体对象
* 继承：可以实现现有类的所有功能，并可以对现有类的功能进行扩展。
  * 继承的类称为子类或派生类，被继承的类称为基类、父类、超类。
  * 父类具有子类的共性，子类拥有父类没有的特性。如：把人当作基类，男人、女人可以作为子类，二者具备不同的特性。
  * 子类中可以通过super使用父类方法
* 多态：同一个行为在不同情形下可以有不同的表现形式。
  * 方法多态：重写和重载
  * 对象多态：父类和子类对象间的转化
    * 向上转型：子类对象变为父类对象。父类 变量名称 = 子类实例。（自动转换）
    * 向下转型：父类对象变为子类对象。子类 变量名称 = (子类) 父类实例。（需要强制转换）
  * 参数多态：定义函数、变量时不指定具体类型，把类型作为参数使用。如Java泛型（也叫参数化类型）

## 重写和重载

|            | 重载(Overload)                                               | 重写(Override)                                               |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义       | 同一个类中，同一个方法名称，根据不同参数列表，可以完成不同的功能。 | 父类和子类具有同一个方法，通过操作不同子类对象，可以完成不同的功能。 |
| 要求       | 相同方法名，参数列表不同。即方法签名不同。                   | 具有相同的方法名，参数，返回类型。即方法签名相同             |
| 时期       | **编译时多态**：编译时根据方法签名（方法名和参数列表）确定调用的方法 | **运行时多态**：运行时根据变量指向的实际对象确定真正调用的方法 |
| 访问修饰符 | 可以改变访问修饰符                                           | 重写方法访问权限不能比父类严格，但是可以比父类更松           |
| 抛出异常   | 可以抛出新的或更广的异常                                     | 重写方法抛出异常范围不能比父类大（**RuntimeException除外**），但是可以比父类异常范围更小或更少 |
| 发生类     | 可以发生在一个类中，也可以发生在父类和子类中                 | 发生在父类和子类中，要求有类继承或接口实现                   |
| 备注       | **只有返回值相同不能重载。**                                 | **final方法无法重写**                                        |

每一个变量都有两种类型，`ClassA obj = new ClassB();`

- 静态类型（编译时类型、引用类型）：引用变量的类型，在编译期确定，无法改变。即`ClassA`
- 动态类型（运行时类型、实际类型）：实例对象的类型，在编译期无法确定，需要运行期确定，可以改变。即`ClassB`

## 继承与实现

|        | 继承（Inheritance）                                          | 实现（Implement）                                            |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义   | 如果多个类的某个部分的功能相同，那么可以抽象出一个类，把他们的相同部分都放到父类里，让他们都继承这个类。 | 如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，让不同的类根据各自的具体逻辑实现这个接口。 |
| 目的   | 继承父类功能，复用代码。父类有具体实现                       | 对多个类都具备的特定的行为定义一个公共标准。不包含具体实现   |
| 举例   | 鸟类会飞，相应的继承鸟类的麻雀、燕子等，也具备飞的功能       | 飞机和鸟都有飞的行为，但是飞的方式不同，具有不同的实现       |
| 关键字 | 使用extends                                                  | 使用implementation                                           |
| 备注   | 抽象类可以定义抽象方法，抽象方法强制要求子类实现，非抽象方法不强制要求 | 接口方法默认是抽象的，强制要求子类实现。Java8之后接口可以有默认实现，使用default修饰 |
|        | 基类可以定义自己的属性、方法等                               | 接口的属性和方法只能是public的。属性只能是全局常量(static final)，方法不能用final修饰 |
|        | 一个类只能继承一个类                                         | 一个类可以实现多个接口                                       |

补充：

1. 继承和实现都是描述两个类间的关系，继承关系比实现关系更加紧密：只要两个类有一定的相似性就可以抽取接口，而继承要求子类和父类有大部分共性，子类是由父类衍生出来的。
2. 继承和实现并不完全对应类和接口。继承关系中，子类也可以有实现。Java8中，接口可以有默认实现，子类可以继承默认实现
3. 一个接口可以继承多个父接口（不需要实现）。A extends B,C
4. 子类属性会覆盖父类的同名属性。

### 多继承带来的问题？

![](面向对象/多继承菱形问题.png)

菱形问题：如图，D类继承B类和C类，B类和C类又同时继承A类。D会因为多继承，继承到两份A类的属性和方法。

C++引入了虚继承解决菱形问题。Java类不允许多继承，但是接口支持多继承，并且Java8中接口也可以有默认实现。

> 如果B和C接口有同名方法，且都有默认实现，则D类需要重写方法。
>
> 如果A和B接口有同名方法，且都有默认实现，则使用B接口的默认实现，相当于B接口重写了方法

### 问题

```java
public class Main {
  public void test() {
    Object s = null;
    foo(s); //编译错误，大类型无法转为小类型，需要强制转换
    foo(null); //编译错误，无法确定调用哪个重载方法
  }
  private void foo(String s) {}
  private void foo(Integer s) {}
}
```

```java
public class Main {
  public void test() {
    foo(1); //调用double方法。此时不会自动装箱，会进行自动类型转换
  }
  private void foo(double s) {}
  private void foo(Integer s) {}
}
```

## 继承与组合

| 继承                                                         | 组合                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| 强调对象是什么的关系。即`is-a`                               | 强调整体与部分拥有的关系，即`has-a`              |
| 不支持动态继承：编译时就确定好两个类的继承关系，运行时无法替换父类 | 支持动态组合：可以在运行时选择不同类型的组合对象 |
| 自动继承父类的功能                                           | 不能自动继承父类的功能，需要手动包装方法         |
| 创建子类对象的时候，无须创建父类对象                         | 创建整体类对象时，需要先创建局部类对象并传入     |

**多用组合，少用继承**

1. 继承和组合都体现了类的复用性
2. 组合比继承耦合度低，更灵活，更容易扩展
3. 两个类确实存在`is-a`关系的时候才使用继承

## 类的定义

### 访问修饰符

Java中有四种访问修饰符，可以修饰类、属性、方法，默认访问修饰符是default。在接口中默认是public，default表示接口默认实现

1. public：所有类和对象都可访问
2. protected：**同一个包中的类，以及其他包的子类可访问**
3. default：同一个包中的类可以访问，其他包的类不可访问，即使是子类
4. private：除了当前类可以访问，其他类都不能访问，包括子类

### 变量

1. 类变量（静态变量）：存储在JVM方法区中，类加载的时候初始化
2. 成员变量：存储在JVM堆内存中，有默认初始值，创建对象的时候初始化
3. 局部变量：存储在JVM栈内存中，没有默认初始值，使用之前需要赋值

### 构造函数（构造方法）

构造函数是特殊的方法，用来创建并初始化对象。

特点：

1. 没有返回类型
2. 不会被继承
3. 名称和所属类的名称相同
4. 没有声明构造函数的情况下，会生成默认无参构造函数。如果手动定义了一个有参数的构造函数，不会再生成默认无参构造函数

### this和super

1. 通过this引用自身属性和方法。通过super引用父类属性和方法。
2. this和super是具体对象的引用，无法在静态环境中使用：包括静态方法、静态变量、静态内部类、静态代码块等
3. this一般可以缺省，除非有同名的局部变量，无法指代的时候。
4. 在内部类中（非静态内部类、匿名内部类），需要使用`类名.this.属性/方法`、`类名.super.属性/方法`进行引用
5. 构造方法引用不需要`.`，如`this(参数列表)，super(参数列表)`
6. 不能在普通方法中使用this和super调用构造方法，只能在其他构造方法中。
7. 使用this和super调用构造方法的时候，必须放在构造函数的第一行
8. 在一个构造方法中不能同时调用this和super构造方法：不能调用两次this，不能调用两次super，也不能一次this一次super。
9. 子类构造方法中会隐式的调用父类无参构造函数，即`super()`。如果父类没有默认无参构造函数，编译器会报错，需要使用super手动调用有参构造函数。

### 常用关键字

1. abstract：只能修饰类和方法，只能在抽象类或接口中使用，接口方法默认是抽象的。

   1. 抽象类不能直接实例化。可以`new A() {}`实例化，实际上是创建了一个匿名内部类
   2. 抽象方法不能有具体实现，需要由子类实现方法。
   3. 不能和private、final、static、synchronized、native共存。修饰静态内部类的时候可以和static共存

2. final表示不可修改。

   1. 修饰变量：表示不可修改，即常量。对于基本数据类型表示值不可改变，对于引用数据类型，表示引用地址不可改变
   2. 修饰类：表示不可被继承
   3. 修饰方法：表示不可被重写。

3. static表示静态：修饰成员变量、方法、内部类、代码块

   1. 和类绑定，不和对象实例绑定。

   2. 只在**类首次加载的时候初始化**，在内存中只有一个副本，存储在方法区中。

   2. 静态方法或静态代码块中，不能使用非静态变量。

   3. 需要使用`类名.`进行引用，直接使用对象引用会有警告。反编译之后发现
   
      ```java
      //定义一个A类和一个静态方法
      //源代码如下
      new A().funStatic();
      //反编译结果如下
      new A();
      A.funStatic();
      ```

# 类的初始化

## 继承时构造方法

* 子类构造方法总是先调用父类的构造方法，如果没有显式指明调用父类哪个构造方法，则默认调用无参构造方法
* 若父类没有无参构造方法，子类需要在自己的构造函数中显式调用父类的构造函数`super(arg);`，并且一定要在第一行调用。若不调用，编译器会报错

## 继承时初始化顺序

- 父类的静态变量
- 父类静态代码块
- 子类的静态变量
- 子类的静态代码块
- 父类的普通变量
- 父类普通代码块
- 父类无参构造函数
- 子类的普通变量
- 子类普通代码块
- 子类无参构造函数

## 数组定义和初始化

* 动态初始化：先声明数组大小，之后赋值，由系统分配默认值。基本数据类型使用各自的默认值，引用数据类型（包括String）默认值为null
* 静态初始化数组时，不必指明长度： `int[] a = {1, 2, 3}`
* 定义多维数组时，其一维数组的长度必须首先指明，其他维数组长度可以稍后指定； 
* “[]” 是数组运算符的意思，在声明一个数组时，数组运算符可以放在数据类型与变量之间，也可以放在变量之后。
* 数组长度只能用short或int限定，否则会编译错误，如`char[] a = new char[1L]`

二维数组声明可以如下：

```java
int a[][] = new int[10][10];
int []b[] = new int[10][10];
int [][]c = new int[10][10];
//多维数组可以先声明第一维长度，后面的长度可以稍后声明
int d[][] = new int[10][];
```

# 五大基本原则

SOLID原则+迪米特法则，具体解释看[设计模式-面向对象六大原则](/设计模式/面向对象六大原则.md)

* 单一职责（SRP，Single-Responsibility Principle）：一个类只做一件核心的事，只有一个引起它的变化
* 开闭原则（OCP，Open-Closed Principle）：对扩展开放，对修改关闭
* 里氏替换原则（LSP，Liskov-Substitution Principle）：任何使用父类的地方，都能够被其子类替换
* 接口隔离原则（ISP，Interface-Segregation Principle）：使用多个专门的小接口，避免使用大的总接口
* 依赖倒置原则（DIP，Dependency-Inversion Principle）：高层模块不依赖于底层模块，二者都依赖于抽象。抽象不应该依赖具体，具体依赖于抽象
* 迪米特法则（LoD，Law of Demeter）：也叫做最少知识原则。一个对象对其他对象应当尽可能少的了解。

# 细节

## &&和&的区别

* &&：短路与，即前面的表达式能确定结果就不执行后面的表达式，可以用来代替简单的if语句
* &：不短路与，前后表达式都需要执行

## equals和==

==判断是否是同一个对象（对于非基本类型）

equals判断的是内容是否相同，可以通过重写对象的equals方法来自定义比较规则

```java
//例
String a = new String("123");
String b = new String("123");
System.out.println(a==b);//false
System.out.println(a.equals(b));//true
```

# 结语

参考文章：

* [「Java 路线」| 方法调用的本质（含重载与重写区别）](https://www.jianshu.com/p/b5b919f24f82)

