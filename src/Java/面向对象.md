---
layout: post
title: 面向对象
date: 2018-12-21
description: Java基础之面向对象
categories: Java
tags: 
- Java
---

# 面向对象

* 面向过程（Procedure Oriented）：把问题分解成一个个步骤，按照步骤调用函数。
  * 自上而下，先定好函数入口，再逐步实现用到的方法
  * 一个类具备各种各样的功能。
  * 代码重用性低、扩展能力差，后期维护困难，代码耦合高。
* 面向对象（Object Oriented）：把属性、行为封装成对象，对同类对象提取共性，形成类，通过不同对象之间的组合、调用解决问题。
  * 自下而上，先设计组件，再通过对象间组合、调用，完成业务逻辑。
  * 每个类只负责自己的属性和功能。
  * 性能比面向过程低

## 三大特性

* 封装：对客观事物进行抽象。将对象的属性和行为封装成一个类，并可以设置属性和方法对外的可见性。
  * 类描述了一类事物的状态和行为。如：把人抽象成一个类，有四肢、五官，可以说话、走路
  * 类是对象的抽象，对象是类的具体。类可以看作是对象的模板，一个类可以有多个对象。如：人是一个类，一个人是具体对象
* 继承：可以实现现有类的所有功能，并可以对现有类的功能进行扩展。
  * 继承的类称为子类或派生类，被继承的类称为基类、父类、超类。
  * 父类具有子类的共性，子类拥有父类没有的特性。如：把人当作基类，男人、女人可以作为子类，二者具备不同的特性。
* 多态：同一个行为在不同情形下可以有不同的表现形式。
  * 方法多态：重写和重载
  * 对象多态：父类和子类对象间的转化
    * 向上转型：子类对象变为父类对象。父类 变量名称 = 子类实例。（自动转换）
    * 向下转型：父类对象变为子类对象。子类 变量名称 = (子类) 父类实例。（需要强制转换）

## 五大基本原则（SOLID）

具体解释看[设计模式-SOLID原则](//todo)

* 单一职责（SRP，Single-Responsibility Principle）：一个类只做一件核心的事，只有一个引起它的变化
* 开闭原则（OCP，Open-Closed Principle）：对扩展开放，对修改关闭
* 里氏替换原则（LSP，Liskov-Substitution Principle）：任何使用父类的地方，都能够被其子类替换
* 接口隔离原则（ISP，Interface-Segregation Principle）：使用多个专门的小接口，避免使用大的总接口
* 依赖倒置原则（DIP，Dependency-Inversion Principle）：高层模块不依赖于底层模块，二者都依赖于抽象。抽象不应该依赖具体，具体依赖于抽象
* 迪米特法则（LoD，Law of Demeter）：也叫做最少知识原则。一个对象对其他对象应当尽可能少的了解。

## 重写和重载

**覆盖在运行时决定**，**重载是在编译时决定**。**并且覆盖和重载的机制不同**

* 重写：子类对父类方法重新定义，具有相同的方法名，参数，返回类型，若是重写了方法，则要使用父类方法需要使用super，子类访问权限不能比父类严格，子类抛出异常范围不能比父类大（RuntimeException除外）
* 重载：参数个数、类型不同，返回值可以不同

## 数组定义

* 定义一维数组时，必须显式指明数组的长度； 
* 定义多维数组时，其一维数组的长度必须首先指明，其他维数组长度可以稍后指定； 
* 采用给定值初始化数组时，不必指明长度； `int[] a = {1, 2, 3}`
* “[]” 是数组运算符的意思，在声明一个数组时，数组运算符可以放在数据类型与变量之间，也可以放在变量之后。

二维数组声明可以如下：

```java
int a[][] = new int[10][10];
int []b[] = new int[10][10];
int [][]c = new int[10][10];
//多维数组可以先声明第一维长度，后面的长度可以稍后声明
int d[][] = new int[10]【】;
```

# 细节

## &&和&的区别

* &&：短路与，即前面的表达式能确定结果就不执行后面的表达式，可以用来代替简单的if语句
* &：不短路与，前后表达式都需要执行

## 接口可以继承多个接口

* 类只能继承一个类，但可以实现多个接口
* 接口不可以实现接口，但可以继承多个接口（不用实现） A extends B,C

## equals和==

==判断是否是同一个对象（对于非基本类型）

equals判断的是内容是否相同，可以通过重写对象的equals方法来自定义比较规则

```java
//例
String a = new String("123");
String b = new String("123");
System.out.println(a==b);//false
System.out.println(a.equals(b));//true
```

## String常量池

```java
String a = "123";
String b = "123";
System.out.println(a==b);//true：同一个对象。
//使用双引号创建的是字符串常量，存储在常量池中
//创建常量对象的时候会先判断常量池中是否已经存在，如果存在则直接引用

String a = "123";
String b = new String("123");
System.out.println(a==b);//false
//使用new String创建对象，存放在堆中，两个引用不相等
//实际上是将常量池中的123复制到了堆中，如果常量池没有，会先再常量池中创建，如下

String a = new String("123");
//实际上创建了两个对象，一个在常量池，一个在堆中
//如果前面常量池已经有该字符串，则只创建一个对象。
```

## 继承时构造方法

* 子类构造方法总是先调用父类的构造方法，如果没有显式指明调用父类哪个构造方法，则默认调用无参构造方法
* 若父类没有无参构造方法，子类需要在自己的构造函数中显式调用父类的构造函数`super(arg);`，并且一定要在第一行调用。若不调用，编译器会报错

## 继承时初始化顺序

- 父类的静态变量
- 父类静态代码块
- 子类的静态变量
- 子类的静态代码块
- 父类的普通变量
- 父类普通代码块
- 父类无参构造函数
- 子类的普通变量
- 子类普通代码块
- 子类无参构造函数





**某个类有两个重载方法：void f(String s) 和 void f(Integer i)，那么 f(null) 的会调用哪个方法？**


A. 前者
B. 后者
C. 随机调用
D. 编译出错

**某个类有两个重载方法：void g(double d) 和 void g(Integer i)，那么 g(1) 的会调用哪个方法？**

A. 前者
B. 后者
C. 随机调用
D. 编译出错

**HashMap 初始容量 10000 即 new HashMap(10000)，当往里 put 10000 个元素时，需要 resize 几次（初始化的那次不算）？**

A. 1 次
B. 2 次
C. 3 次
D. 0 次

# 参考文章

[什么是Java中的自动拆装箱](https://blog.csdn.net/wufaliang003/article/details/82347077)

[你真的知道Java中boolean类型占用多少个字节吗？](https://www.jianshu.com/p/2f663dc820d0)

待补充更新知识点：//todo

https://www.jianshu.com/p/b5b919f24f82

https://www.jianshu.com/p/2adb8fe74987

https://mp.weixin.qq.com/s/63TOcAyQL9LIEX9UHLtmyw

https://blog.csdn.net/sugar_no1/article/details/86366714