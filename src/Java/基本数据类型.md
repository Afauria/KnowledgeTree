---
layout: post
title: Java基本数据类型
date: 2018-12-21
description: 基本数据类型介绍、自动拆装箱、整型缓存机制、常见错误和注意事项。
categories: Java
tags: 
- Java
---

# 基本数据类型

## 8种基本数据类型

* 字符型：char（实际是一个16位无符号整数）
* 布尔型：boolean
* 数值型：
  * 整型：byte、short、int、long
  * 浮点型：float（单精度）、double（双精度）

> String不是基本数据类型，是引用类型

实际上，Java中还存在另外一种基本类型`void`，它也有对应的包装类`java.lang.Void`，不过我们无法直接对它们进行操作。

## 类型间转换

1. 隐式类型转换：小类型可以自动转为大类型，发生在赋值的时候，如果右侧是表达式，会先计算表达式，再进行隐式类型转换。
2. 大类型转到小类型需要强制转换，否则可能会造成精度损失，提示编译错误。除非使用强制转换
3. 表达式运算的时候涉及多种数据类型，会自动向较大类型转换
4. byte、char实际上都是整数类型，计算的时候会转为int进行计算

```java
//byte和char参与运算，会转换为int类型
byte m = 97;
char n = 97;
System.out.println(m); //97
System.out.println(n); //a
System.out.println(m + n); //194
```

## 存储大小

| 基本数据类型（内置类型） | 对应的包装类型 | 大小             |
| ------------------------ | -------------- | ---------------- |
| char                     | Character      | 2字节            |
| boolean                  | Boolean        | 1个字节或4个字节 |
| byte                     | Byte           | 1个字节          |
| short                    | Short          | 2个字节          |
| int                      | Integer        | 4个字节          |
| long                     | Long           | 8个字节          |
| float                    | Float          | 4字节            |
| double                   | Double         | 8字节            |

1个字节=8位。以int为例：取值范围为`-2^31`到`2^31-1`，可以使用`Integer.MIN_VALUE`和`Integer.MAX_VALUE`获取最小值和最大值。使用`Integer.SIZE`获取int类型位数。

## 取值范围

8位可以表示的数字是2^8，为什么是[-128,127]，而不是[0,255]?

整型使用**有符号**的二进制补码存储，最高位表示符号位。8位**无符号整数**可以表示[0,255]

```
最小值：10000000（-128）
最大值：01111111（127）
```

## boolean占1或4个字节？

boolean类型理论上只需要1bit空间，但是计算机处理数据的最小单位是1个字节，实际存储的空间是：用1个字节的最低位存储，其他7位用0填补

位（bit）是计算机存储的最小单位，字节是计算机处理数据的最小单位，1字节=8位

> 《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。这样我们可以得出boolean类型**单独使用是4个字节**，在**数组中又是1个字节**。
>
> 使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。

## 数据超出范围？

如果是字面量（直接量）超出int的取值范围，会出现编译错误，如下：

```java
int a = 2147483648;  //int范围为-2147483648 到 2147483647
```

如果是计算结果溢出，不会抛异常，也没有任何提示。因此计算的时候**需要注意数据溢出**的问题。如下：

```java
System.out.println(Integer.MAX_VALUE + 1);  //输出-2147483648
```

## 布尔类型

需要注意的是布尔属性的命名：在阿里巴巴Java开发手册中，要求**对POJO类的布尔类型变量，都不要加is，否则可能会引起序列化错误**。

* 布尔基本类型自动生成getter和setter方法，名称是`isXXX()`和`setXXX()`，（JavaBean规范定义布尔类型getter使用is开头）
* 布尔包装类型自动生成getter和setter方法，名称是`getXXX()`和`setXXX()`

如下

```java
class Model1  {
    private Boolean isSuccess;
    public void setSuccess(Boolean success) {
        isSuccess = success;
    }
    public Boolean getSuccess() {
        return isSuccess;
    }
 }

class Model2 {
    private Boolean success;
    public Boolean getSuccess() {
        return success;
    }
    public void setSuccess(Boolean success) {
        this.success = success;
    }
}

class Model3 {
    private boolean isSuccess;
    public boolean isSuccess() {
        return isSuccess;
    }
    public void setSuccess(boolean success) {
        isSuccess = success;
    }
}

class Model4 {
    private boolean success;
    public boolean isSuccess() {
        return success;
    }
    public void setSuccess(boolean success) {
        this.success = success;
    }
}
```

对于Model2和Model4序列化结果为success，不存在问题

但是对于Model3，严格来说isSuccess变量的getter方法应该为`isIsSuccess()`，但是IDE自动生成默认是`isSuccess()`，在不同序列化框架中结果不一致：

* `fastjson`和`jackson`序列化json字符串的时候会反射遍历所有getter方法，根据JavaBean规范，序列化去掉is作为key。
* `Gson`是反射遍历该类所有属性，使用属性名作为key

```java
public class BooleanMainTest {
    public static void main(String[] args) throws IOException {
        //定一个Model3类型
        Model3 model3 = new Model3();
        model3.setSuccess(true);

        //使用fastjson(1.2.16)序列化model3成字符串并输出
        System.out.println(JSON.toJSONString(model3)); //输出{"name":"Afauria","success":true}

        //使用Gson(2.8.5)序列化model3成字符串并输出
        Gson gson =new Gson();
        System.out.println(gson.toJson(model3)); //输出{"isSuccess":true}

        //使用jackson(2.9.7)序列化model3成字符串并输出
        ObjectMapper om = new ObjectMapper();
        System.out.println(om.writeValueAsString(model3)); //输出{"success":true,"name":"Afauria"}
    }
}

class Model3 implements Serializable {
    private boolean isSuccess;
    public boolean isSuccess() {
        return isSuccess;
    }
    public void setSuccess(boolean success) {
        isSuccess = success;
    }
    public String getName(){
        return "Afauria";
    }
}
```

## char类型

char类型实际上是一个16位无符号整数（16位Unicode字符），范围是[0, 65535]，**存储的是对应字符编码**。如字符a实际值为97，字符A实际值为65，字符0实际值为48

> Java字符类型采用Unicode字符集编码（定长字符集），所有字符都是16位表示。
>
> 范围是'\u0000'到'\uffff'，即0到65535

字符字面量包含在单引号中，对不方便输出的字符，可以采用转义字符`\`表示。如`\n`、`\'`、`\"`等

赋值方式：

1. 使用字符赋值
2. 使用16进制整数赋值
3. 使用十进制整数赋值

```java
char c1 = '中';
char c2 = '\u4e2d';
char c3 = 20013;
System.out.println(c1);  //输出"中"
System.out.println(c2);  //输出"中"
System.out.println(c3);  //输出"中"
```

## 浮点类型

* 定点：小数点固定在某个位置。
* 浮点：使用科学计数法存储数字，小数点位置根据指数大小浮动。可以表示更大范围的数值

例如8位二进制能表示256个整数。表示定点类型的时候，同样只能表示256个实数，例如约定小数位为2位

```
000000.00 // 表示 0.0
000000.01 // 表示 0.25
000000.10 // 表示 0.5
000000.11 // 表示 0.75
000001.00 // 表示 1.0
000001.01 // 表示 1.25
... 
```

我们知道0.0到0.25之间有连续的、无限多个数。而计算机只能处理离散的数据，二进制的位数表示它能表示的离散数据个数（2^n个信息量）。0.0到0.25之间的数字被跳过了。

引入浮点数表示近似值。**不能用浮点型表示金额等重要指标。**建议使用`BigDecimal`或Long（单位为分）表示金额。

为什么浮点数运算不精确？

计算机的存储和运算都是通过二进制，十进制转二进制采用**除2取余，逆序排列**的方式。

如0.25

```
0.25*2=0.5 //整数部分为0
0.5*2=1.0 //整数部分为1
因此0.25表示为二进制为0.01
```

二进制在有些情况下无法精确表示，如下：

```
0.2*2=0.4  //整数部分为0
0.4*2=0.8  //整数部分为0
0.8*2=1.6  //整数部分为1
0.6*2=1.2  //整数部分为1
0.2*2=0.4  //整数部分为0
...
结果为无限循环小数：0.001100110011...
```

# 包装类型

## 为什么需要基本数据类型？

> 对象比较消耗资源：`new`一个对象是存储在堆里的，通过栈中的引用来使用这些对象；对于经常用到的类型，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。
>
> 使用基本数据类型不会在堆上创建，而是直接在栈内存中存储。因此更加高效

## 为什么需要包装类型？

> Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。例如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。
>
> 为了让基本类型也具有对象的特征，就出现了包装类型，将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

## 使用包装类型还是基本数据类型？

**包装类型默认值为null，需要显式的初始化，否则外部调用get方法，由于自动拆箱可能产生NPE**

阿里巴巴Java开发手册建议**POJO类属性、RPC方法返回值和参数使用包装类型**

> 1. 提醒使用者传入初始值，否则可能产生NPE
> 2. 如int，默认值0是合法值，null是非法值，可以通过null判断调用失败，阻断程序，异常退出。如果使用基本数据类型，系统可能不会报错，使用0参与运算。

# 自动装箱/拆箱

装箱（boxing）：将基本类型转换成对应的包装类型。拆箱（unboxing）则反过来

* 在Java SE5之前，手动装箱：`Integer i = new Integer(10);`
* 在Java SE5中，提供了自动装箱、拆箱功能

自动装箱、拆箱原理：编译时使用包装类的`valueOf()`和`xxxValue()`方法进行拆装箱

举例：

```java
public static void main(String[]args){
  Integer i = 10;  //自动装箱
  int b = i;     //自动拆箱
}
```

将上述代码反编译后得到

```java
public static void main(String[]args){
  Integer a = Integer.valueOf(10); //装箱
  int b = a.intValue(); //拆箱
}
```

**注：**

1. 如果包装类型是`null`，拆箱`null.intValue()`会发生NPE
2. 循环中大量拆装箱操作会浪费很多资源
3. 方法重载问题：例如集合类`remove(int index)`和`remove(Object obj)`，Object为Integer，此时不会发生拆装箱

## 常见场景

可以使用`javac`编译之后`javap -c`查看汇编指令。也可以通过工具（如`jd-gui`）反编译查看代码

```java
//基本数据类型放入集合类
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i ++){
    li.add(i);
}
```

```java
//包装类型与基本数据类型比较
//理论上==是比较对象地址，这里实现了拆箱
Integer a=1;
System.out.println(a==1?"等于":"不等于");//等于
Boolean bool=false;
System.out.println(bool?"真":"假");//真
```

```java
//包装类型的运算
Integer i = 10;
Integer j = 20;
System.out.println(i+j);
```

```java
//三目运算符使用，当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。
boolean flag = true;
Integer i = 0;
int j = 1;
int k = flag ? i : j;//这里对i进行拆箱，如果是null，会发生NPE，拆箱：i.intValue();
```

```java
//函数参数和返回值
//自动拆箱
public int getNum1(Integer num) {
 return num;
}
//自动装箱
public Integer getNum2(int num) {
 return num;
}
```

## 装箱缓存

Java5对自动装箱提供了**缓存机制**，对常用范围内的包装对象进行缓存和重用，避免频繁创建对象，节省内存、提高性能。

```java
public class Main {
	public static void main(String[] args) {
		Integer a = 127;
		Integer b = 127;
		System.out.println(a == b);  //输出true
		Integer c = 128;
		Integer d = 128;
		System.out.println(c == d);  //输出false
    //只适用于自动装箱，直接new比较不相等
		Integer e = new Integer(127);
		Integer f = new Integer(127);
		System.out.println(e == f); //输出false
	}
}
```

**注：**

1. 只适用于自动装箱，使用构造函数主动创建对象不适用。推荐使用`valueOf`方法定义整型，会取缓存，直接new不会取缓存
2. 除了int之外，也有`ByteCache、ShortCache、LongCache、CharacterCache`缓存对应类型的对象
3. byte、short、int、long范围是-128到127，Character范围是0到127
3. Boolean使用TRUE、FALSE常量缓存
3. 浮点型float、double没有缓存，直接构造新对象返回

原理：上面提到自动装箱原理是使用`valueOf()`方法返回包装类。

1. 查看`valueOf()`源码，内部使用一个`cache`数组进行缓存，数组中存在会返回同一个对象

```java
public static Integer valueOf(int i) {
  if (i >= IntegerCache.low && i <= IntegerCache.high)
    return IntegerCache.cache[i + (-IntegerCache.low)];  //数组缓存对象
  return new Integer(i);
}
```

2. `IntegerCache`中类初始化的时候循环创建对象，存入数组

# 常见问题

1. `System.out.println(5 / 10 * 10);` 输出结果为0，而不是5

2. 有long类型数据参与运算，结果才是long类型，由于是先计算右侧表达式，因此还未进行隐式类型转换。

```java
//隐式类型转换：小类型可以自动转为大类型
long m = 100;
System.out.println(m);
//有long类型数据参与运算，结果才是long类型
long h = Integer.MAX_VALUE + 1;
long i = Integer.MAX_VALUE + 1L;
System.out.println(h); //输出-2147483648
System.out.println(i); //输出2147483648
```

3. 表达式出现多种数据类型，自动向大类型转换

```java
double persent1 = 80 / 100; //结果为0.0，先计算右侧表达式，再进行隐式类型转换
double persent2 = 80.0 / 100; //结果为0.8，右边表达式有double型直接量参与， 运算结果为double型
```

4. long类型数据赋值给int，会出现编译错误，提示“不兼容的类型: 从long转换到int可能会有损失”。除非强制转换

```java
//编译错误，提示“不兼容的类型: 从long转换到int可能会有损失”，除非强制转换
// int j = 1L;
int j = (int) 1L;
```

5. 浮点数默认是double类型，如果要使用float，需要加`f`或`F`后缀。double也可加`d`或`D`表示double类型

```java
//编译错误：提示“不兼容的类型: 从double转换到float可能会有损失”
float k = 3.14;
```

6. 浮点运算会出现舍入误差，需要使用`BigDecimal`

```java
System.out.println(3.0-2.9);  //输出0.10000000000000009
System.out.println(3.0f-2.9f);  //输出0.099999905
```

0.1和1万亿，请问哪个数能用二进制数精确表示？

> 0.1转换为二进制是无限循环小数，无法精确表示，1万亿可以精确表示

 **1、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?**

 答：对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

 对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

 

 **2、char类型变量能不能储存一个中文的汉字，为什么？**

char类型变量是储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的，还有一种特殊情况就是某个生僻字没有包含在unicode编码字符集中，那么就char类型就不能存储该生僻字。

 

 **3、Integer和int的区别**

int是java的8种内置的原始数据类型。Java为每个原始类型都提供了一个封装类，Integer就是int的封装类。

int变量的默认值为0，Integer变量的默认值为null，这一点说明Integer可以区分出未赋值和值为0的区别，比如说一名学生没来参加考试，另一名学生参加考试全答错了，那么第一名考生的成绩应该是null，第二名考生的成绩应该是0分。关于这一点Integer应用很大的。Integer类内提供了一些关于整数操作的一些方法，例如上文用到的表示整数的最大值和最小值。

 

 **4、switch语句能否作用在byte上，能否作用在long上，能否作用在string上？**

 byte的存储范围小于int，可以向int类型进行隐式转换，所以switch可以作用在byte上

 long的存储范围大于int，不能向int进行隐式转换，只能强制转换，所以switch不可以作用在long上

 string在1.7版本之前不可以，1.7版本之后switch就可以作用在string上了

 

**5.是否存在 x>x+1?为什么？**

 这就是临界值，当x=最大值 时； 再加1（根据二进制运算+1）就超过了它的临界值，刚好会是它最小值。 

举个例子吧，byte 8位， -128 ~ 127  

127 二进制： 0111 1111

1 二进制 ：   0000 0001

相加结果：   1000 0000

byte 8位 **有符号**，  1000 0000 刚好 为 -128



float a = 0.125f; double b = 0.125d; System.out.println((a - b) == 0.0); 代码的输出结果是什么？
A. true
B. false

**double c = 0.8; double d = 0.7; double e = 0.6; 那么 c-d 与 d-e 是否相等？**
A. true
B. false



**System.out.println(1.0 / 0); 的结果是什么？**


A. 抛出异常
B. Infinity
C. NaN



**System.out.println(0.0 / 0.0); 的结果是什么？**


A. 抛出异常
B. Infinity
C. NaN
D. 1.0



**>> 和 >>> 的区别是？**


A. 任何整数没有区别
B. 负整数一定没有区别
C. 浮点数可以 >> 运算，但是不可以 >>> 运算
D. 正整数一定没有区别



**某个类有两个重载方法：void f(String s) 和 void f(Integer i)，那么 f(null) 的会调用哪个方法？**


A. 前者
B. 后者
C. 随机调用
D. 编译出错

**某个类有两个重载方法：void g(double d) 和 void g(Integer i)，那么 g(1) 的会调用哪个方法？**


A. 前者
B. 后者
C. 随机调用
D. 编译出错



**String a = null; switch(a) 匹配 case 中的哪一项？**


A. null
B. "null"
C. 不与任何东西匹配，但不抛出异常
D. 直接抛出异常



**<String, T, Alibaba> String get(String string, T t) { return string; } 此方法：**


A. 编译错误，从左往右第一个 String 处
B. 编译错误，T 处
C. 编译错误，Alibaba 处
D. 编译正确



**HashMap 初始容量 10000 即 new HashMap(10000)，当往里 put 10000 个元素时，需要 resize 几次（初始化的那次不算）？**


A. 1 次
B. 2 次
C. 3 次
D. 0 次

# 结语

案例汇总

```java
public class Main {
	public static void main(String[] args) {
		//缓存范围-128到127
		Integer a = 127;
		Integer b = 127;
		System.out.println(a == b);  //输出true
		Integer c = 128;
		Integer d = 128;
		System.out.println(c == d);  //输出false
        //缓存只适用于自动装箱
		Integer e = new Integer(127);
		Integer f = new Integer(127);
		System.out.println(e == f); //输出false
		System.out.println(Integer.MAX_VALUE + 1); //输出-2147483648
		//编译错误，提示“过大的整数”
		// int g = 2147483648;
		System.out.println(5 / 10 * 10); //输出0，而不是5

		//隐式类型转换：小类型可以自动转为大类型
		//有long类型数据参与运算，结果才是long类型
		long h = Integer.MAX_VALUE + 1;
		long i = Integer.MAX_VALUE + 1L;
		System.out.println(h); //输出-2147483648
		System.out.println(i); //输出2147483648
		//编译错误，提示“不兼容的类型: 从long转换到int可能会有损失”，除非强制转换
		// int j = 1L;
		int j = (int) 1L;
		
		//浮点数默认为double类型，如果要使用float，需要加f或F后缀。
		//编译错误：提示“不兼容的类型: 从double转换到float可能会有损失”
		//float k = 3.14;
		float l = 3.14f;
		//舍入误差
		System.out.println(3.0-2.9);  //输出0.10000000000000009
		System.out.println(3.0f-2.9f);  //输出0.099999905

		//byte、char实际上都是整数类型，计算的时候会转为int进行计算
		byte m = 97;
		char n = 97;
		System.out.println(m); //97
		System.out.println(n); //a
		System.out.println(m + n); //194

		//表达式出现多种数据类型，自动向大类型转换
		double o = 80 / 100; //结果为0.0，先计算右侧表达式，再进行隐式类型转换
		double p = 80.0 / 100; //结果为0.8，右边表达式有double型直接量参与， 运算结果为double型

		char c1 = '中';
		char c2 = '\u4e2d';
		char c3 = 20013;
		System.out.println(c1);
		System.out.println(c2);
		System.out.println(c3);
		
	}
}
```

带有中文注释，编译的时候需要指定UTF-8编码`javac -encoding UTF-8 Main.java`，再使用`java Main`执行



参考文章：

* [什么是Java中的自动拆装箱](https://blog.csdn.net/wufaliang003/article/details/82347077)
* [Java工程师成神之路](https://hollischuang.github.io/toBeTopJavaer)
* [「计算机原理」| 为什么浮点数运算不精确？](https://www.jianshu.com/p/2adb8fe74987)