

# 进程

进程（Process）是系统资源分配的基本单位，操作系统为每个进程分配独立的地址空间。

* 一个进程无法访问另一个进程的变量和数据结构。
* 一个进程的崩溃不会影响另一个进程。

进程是系统中**正在运行**的一个程序，程序一旦运行就是进程。进程可以看成程序执行的一个实例。（程序是静态的，进程是动态的）

每启动一个Java程序，都会启动一个虚拟机。

## 用户空间和内核空间

* 用户空间：运行用户程序，进程间独立。
* 内核空间：运行内核程序，具备更高的权限，资源共享。

由于内核空间是共享的，因此用户空间的进程交换需要通过内核。

由于设备会进行访问控制（Access Control），因此用户空间的程序无法直接访问设备资源。

CPU从用户空间切换到内核空间主要有两种方式：

* 中断（Interrupt）：CPU在每个时钟周期末尾检测是否有中断信号到达，如果有，则根据优先级决定是否去处理中断指令。（可以看作是CPU级别的轮询）
* 系统调用（System Call）：操作系统提供给应用程序的接口，通过System Call调用系统内核操作。（例如设备读写）

## 进程间的关系

多进程之间存在两种关系：

1. 竞争关系（间接制约）：进程之间没有直接关系，彼此不知道各自的存在。但是由于这些进程共用一套计算机资源（硬件设备、存储器、处理器、文件等），因此会出现资源竞争。
2. 协作关系（直接制约）：多个进程为了完成同一个任务需要分工协作，一方先执行完成后会阻塞，等到其他合作进程都执行完成之后，再通过协调信号或消息唤醒，再继续执行。协作关系又分为两种
   1. 松散协作：例如共同写文件，A进程先写完前半段，B进程等A写完之后再写后半段。
   2. 紧密协作：进程间需要互相通信。例如共同写文件，A进程把前半段数据发给B进程，B进程把两段内容合到一起，写入文件。

> 协作可能需要竞争，也可以不需要竞争
>
> 竞争关系可以看作是一种特殊的协作，对资源使用上的协调

竞争会产生两个问题：

1. 死锁（deadlock）：两个进程都获得了部分资源，并且还需要其他进程所占有的资源。
2. 饥饿（starvation）：一个进程由于其他进程优先，而被无限期拖延。

补充下死锁的必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，不释放已获得的资源。
3. 不剥夺条件：进程已获得的资源，在未使用完成前，不能被强行剥夺。
4. 循环等待条件：多个进程之间形成头尾相接的循环等待资源关系。A等待B，B等待C，C等待A

## 互斥、同步、通信

网上的文章经常把进程/线程的同步和通信方式放一起，很混乱。这里做下区分，谈下自己的理解。以进程为例（线程同理）

为了解决进程间竞争的关系，引入了**互斥**，为了解决进程间的协作关系，引入了**同步**

* 进程的互斥（mutual exclusion）：指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。
* 进程的同步（synchronization）：指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。
* 进程的通信（Inter-Process Communication）：两个进程间建立紧密的联系，互相交换数据或信息。

> 跨进程调用本质也是进程间的通信，只不过发送的信息是要调用的方法名。双方定义一套协议，接收到该消息的时候调用指定的方法。

**进程互斥是一种特殊的同步**：互斥是B进程等A进程释放资源，同步可以是B进程等A进程发送消息，也可以是等A进程释放资源

**进程同步是一种特殊的通信**，无法交换数据，只是传递信号或状态。进程间通信更倾向于数据交换

> 从名词上解读，感觉同步更像是目的，为了确定进程的执行顺序，或者同步双方数据和状态。
>
> 通信更像是一种机制，可以利用这种机制实现同步。当然也可以用来做其他事情。

想到个例子：游戏中打副本，有多个小队，小队之间是竞争关系，也是松散协作（一同打Boss），小队内的成员是紧密的协作，要频繁的通信

## 进程间通信

为了做区分，这里认为同步方式用于交换少量信息（低级通信机制），通信方式用于交换数据（高级通信机制）。

> 当然进程间通信方式也能用来做同步，同步方式则不一定能用来通信。

同步方式：

* 信号（signal）： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
* 信号量（semophore） + 原语操作（PV）：限制同一时刻访问资源的进程数目。（P申请资源，S减1，V释放资源，S加1）
* 互斥锁（mutex）：是一种特殊的信号量，n=1。只允许一个进程访问。

通信方式：

* 管道（Pipe）：一种半双工的通信方式，数据只能单向流动，并且只有父子进程能通信
* 有名管道（named pipe）FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系的进程通信。
* 消息队列（MessageQueue）：将消息链表存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
* 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制（如信号量）配合使用，来实现进程间的同步和通信。
* 内存映射（mmap）
* 套接字（socket）：可用于不同机器间的进程通信。



# 线程

线程（Thread）是系统（CPU）调度的基本单位。线程是进程的一个实体，是进程的一条执行路径。

一个进程至少拥有一个线程去执行。程序启动默认会开启一个主线程。

一个进程可以拥有多个线程，共享进程的地址空间和资源。每个线程拥有独立的栈空间。

## 进程和线程的区别

1. 进程之间地址空间和资源独立，线程间共享本进程的地址空间和资源（例如内存、I/O、CPU、文件等），一个线程修改了内存，另一个线程可以知道。
2. CPU在进程间调度和切换开销较大，在线程间调度和切换开销较小。
3. 进程通信往往需要内核参与，而线程通信是在同一地址空间内，无需内核参与，效率更高。（需要进行同步和互斥，保证数据的一致性）
4. 进程是一个可执行程序的实体，线程不是，线程不能脱离进程单独执行。

## 线程状态

<img src="线程/线程状态.png" style="zoom: 80%;" />

1. 新建状态（New）：线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
2. 就绪状态（Runnable，可执行状态）：线程对象被创建并调用`start()`方法启动线程后，处于就绪状态，随时可能被CPU调度执行。
3. 运行状态（Running）：线程获取到CPU执行权限。**线程只能从就绪状态进入到运行状态。不能从新建或阻塞状态直接运行**
4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。例如
   * 等待阻塞：调用`wait()`方法，释放锁，需要`notify`进行唤醒。
   * 同步阻塞：线程获取`synchronized`同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。
   * 其他阻塞：
     * 调用线程的`sleep()`方法使线程休眠：`sleep()`超时之后，线程重新进入就绪状态
     * 其他线程调用了`join()`方法优先执行：`join()`等待线程终止或者超时，线程重新进入就绪状态
     * 发出了I/O请求时：当I/O处理完毕时，线程重新进入就绪状态
5. 死亡状态(Dead)    : 线程执行完了或者因异常退出了`run()`方法，该线程结束生命周期。

## 锁池和等待池

调用`wait()`方法进入等待阻塞，`notify()`唤醒之后进入同步阻塞。这两种阻塞有什么区别呢？

* 锁池：线程A持有某个对象的锁，导致其他线程不能访问该对象的`synchronized`方法（代码块），这些线程就会进入锁池，等待对象的锁被释放，与其他线程竞争锁
* 等待池：线程A调用了某个对象的`wait()`方法，线程A就会释放该对象的锁，进入到该对象的等待池。不会去竞争锁

`notify()`会将等待池中的线程唤醒，被唤醒的线程从等待池进入锁池，与其他线程竞争锁

# 锁

多线程**访问同一资源**才会发生竞争，此时需要进行线程间的资源同步。加锁是线程同步的一种方式。

## 公平和非公平锁

## 自旋锁

**synchronized是非公平锁，线程需要竞争锁**

**公平锁：可以使用FIFO（先进先出），维护一个队列，让先进的线程获得锁**

## Lock和synchronized区别

1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；（I/O和Synchronized都能相应中断，即不需要处理interruptionException异常）
4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
5. Lock可以提高多个线程进行读操作的效率。
6. 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

1 、在使用synchronized关键字的情形下，假如占有锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程就只能一直等待，别无他法。这会极大影响程序执行效率。因此，就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间 (解决方案：tryLock(long time, TimeUnit unit))或者能够响应中断(解决方案：lockInterruptibly())），这种情况可以通过 Lock 解决。

2、当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是如果采用synchronized关键字实现同步的话，就会导致一个问题，即当多个线程都只是进行读操作时，也只有一个线程在可以进行读操作，其他线程只能等待锁的释放而无法进行读操作。因此，需要一种机制来使得当多个线程都只是进行读操作时，线程之间不会发生冲突。同样地，Lock也可以解决这种情况 (解决方案：ReentrantReadWriteLock) 。

3、通过Lock得知线程有没有成功获取到锁 (解决方案：ReentrantLock) ，但这个是synchronized无法办到的。

上面提到的三种情形，我们都可以通过Lock来解决，但 synchronized 关键字却无能为力。事实上，Lock 是 java.util.concurrent.locks包 下的接口，Lock 实现提供了比 synchronized 关键字更广泛的锁操作，它能以更优雅的方式处理线程同步问题。也就是说，Lock提供了比synchronized更多的功能。

# 多线程

https://blog.csdn.net/qq_41291253/article/details/92065354

通过程序设计，让CPU处理多个任务。

优点：

1. 提高程序执行效率
2. 提高CPU资源利用率
3. 线程上的任务完成之后，线程会自动销毁

缺点：

1. 程序设计复杂，需要考虑资源抢占，线程同步
2. 开启线程会占用内存空间。
3. 线程越多，CPU调用开销越大

单核CPU同一时间CPU只能处理一个线程。多核CPU可以同时处理多个线程任务。

空闲CPU数较多的情况下，多线程会充分利用CPU**并行**执行。CPU不足的情况下，会快速地在多个线程间切换执行，造成"同时"执行的效果。

如果线程数较多，CPU频繁切换开销较大，如果不频繁切换则线程执行效率较低。

## 并行和并发

* 并行是同一时刻做多件事情，并发是同一时间间隔内做多件事情
* 并行是同时做很多事情（依靠多核处理）。并发是一次处理很多事情，可以是虚拟的同时执行（轮流占用CPU和各种资源）也可以是真的同时执行。

## 线程间通信

### 共享对象

同一进程中所有线程共享内存区域，因此定义全局变量可供其他线程访问。多线程访问全局变量时最好声明为volatile

volatile能够保证可见性，不能保证原子性，正常情况下内存会拷贝到cpu缓存中，当多个线程运行在不同cpu上的时候对一个变量修改会导致不同步，使用volatile声明之后会直接从内存中读取，不会进行cpu缓存。

synchronized同步能够保证可见性和原子性，同一时刻只允许一个线程访问资源。

synchronized修饰：实例方法、静态方法、代码块

synchronized可以同步方法和同步代码块

```java
//同步代码块，持有this对象的锁
synchronized(this){
    //doSomething……
}
//同步方法，默认传入this
 public synchronized void func() {
 }
```

**synchronized实际上锁住的是对象，而不是代码块**

新建一个实例其他线程仍然可以执行代码块。要想锁住代码块，可以使用下面的方式

```java
//持有class对象的锁
synchronized(Test.class){
    //doSomething……
}
```

### 区别

1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
3. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
4. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的

### while轮询：忙等状态，消耗cpu资源。可使用wait阻塞替代

### 接口回调

### java提供的Callable，Future，ExecutorService。

```java
//ExecutorService提供的方法，传入Callable，submit会封装成FutureTask（继承RunnableFuture接口）然后执行
<T> Future<T> submit(Callable<T> task);
```

Future的get()方法用来获取执行结果，会阻塞线程，直到任务执行完毕。

## 5.4. IO管道流：PipedInputStream，PipedOutputStream

## 5.5. socket套接字

## 5.6. 消息队列

## 5.7. wait()，notify()，notifyAll()阻塞和唤醒线程

 这三个方法都是属于Object的本地final方法；无法被重写，所有类都可以调用这三方法； 

* wait()：使当前线程等待，并且释放锁，直到其他线程调用notify()或者notifyAll()方法唤醒。

* notify()：唤醒一个等待当前对象的锁的线程（随机）。

* notifyAll(）就是唤醒所有在等待当前对象的线程。


wait()和notify()方法要求在调用时线程持有对象的锁，因为线程只有在同步块中才会占用对象的锁，因此对这两个方法的调用需要放在synchronized方法或synchronized块中。

不持有锁的话可能会产生竞态问题，notify可能比wait先执行，导致一直wait

```java
//使用synchronized获取对象锁，在同步块中使用wait方法让当前线程进入等待状态，等待当前锁住的对象，
//同样的在另一个同步块中使用notify方法释放对象锁，唤醒等待该对象锁的线程。
synchronized(obj){
	obj.wait();
}
synchronized(obj){
	obj.notify();
}
```



# 4. 线程间的同步

各个线程可以访问同一进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。数据之间的相互制约包括 
1、直接制约关系，即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系 
2、间接制约关系，即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步

## 4.1. 锁机制：包括互斥锁、读写锁、条件变量

* 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
* 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
* 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

## 4.2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

允许多个线程使用共享资源，规定访问共享资源线程的最大数目

## 4.3. 信号机制(Signal)：类似进程间的信号处理

## 4.4. 临界区

通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

# 5. java线程间的通信方式

## 5.1. 

# 6. 线程状态

## 6.2. yield，sleep，join都是Thread的方法

yield：让步，让当前线程由运行状态进入到就绪状态，从而让其他线程有机会获得cpu（一般是更高优先级的线程，也可能当前线程立马获得cpu）

sleep: 让线程休眠一段时间，进入阻塞状态。放弃cpu，给其他线程执行的机会，但是不释放对象锁，如果加了锁，其他线程还是不能使用资源

join：当前线程挂起，让指定的另一个线程执行。join（long）方法在内部使用的是 wait (long) 方法来实现的；所以join（long）方法具有释放锁的特点。（相当于在程序中间插入了一段代码）

```java
public class Main{
    public static void main(String[] args){
        Thread t = new Thread();
        //主线程会阻塞，直到t线程执行完毕。
        //join的意思是加入，即将线程排队，把t线程加入到队伍里面去
        //也可以传入时间参数，表示主线程只等待一段时间
        t.join();
    }
}
```

sleep是native方法，并且是静态的，一般使用`Thread.sleep(1000);`让当前线程休眠



TODO

https://blog.csdn.net/yusimiao/article/details/105378311

https://yearn.xyz/posts/techs/%E5%8D%8F%E7%A8%8B/
