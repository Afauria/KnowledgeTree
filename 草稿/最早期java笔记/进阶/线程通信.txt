一、进程间的通信方式
# 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
# 有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
# 信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
# 消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
# 信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
# 共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
# 套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。


二、线程间的通信方式

# 锁机制：包括互斥锁、条件变量、读写锁
*互斥锁提供了以排他方式防止数据结构被并发修改的方法。
*读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
*条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
# 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
# 信号机制(Signal)：类似进程间的信号处理
线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。




线程通信：
1.使用共享对象
2.轮询，忙等状态，消耗cpu资源。使用wait阻塞，notify唤醒
3.回调
4.Callable，Future，ExecutorService，future的get方法会阻塞线程
5.管道pipe
6.socket套接字
7.消息队列
8.wait(),notify(),以及notifyAll() 这三个方法都是属于Object的方法；所以所有类都可以继承这三方法； 
wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。
notify()方法会唤醒一个等待当前对象的锁的线程。而notifyAll(）顾名思义；就是唤醒所有在等待中的方法；
wait()和notify()方法要求在调用时线程已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或synchronized块中。


Java提供了一种内联机制可以让线程在等待信号时进入非运行状态。当一个线程调用任何对象上的wait()方法时便会进入非运行状态，直到另一个线程调用同一个对象上的notify()或notifyAll()方法。
为了能够调用一个对象的wait()、notify()方法，调用线程必须先获得这个对象的锁。因为线程只有在同步块中才会占用对象的锁，所以线程必须在同步块中调用wait()、notify()方法。

使用synchronized获取对象锁，在同步块中使用wait方法让当前线程进入等待状态，等待当前锁住的对象，同样的在另一个同步块中使用notify方法释放对象锁，唤醒等待该对象锁的线程。
synchronized(obj){
obj.wait();
}
synchronized(obj){
obj.notify();
}
