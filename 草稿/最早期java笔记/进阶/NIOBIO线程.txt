1、收到一个请求就处理，这个时候就不能处理新的请求，这种为阻塞
这个是单线程模型，无法并发，一个请求没处理完服务器就会阻塞，不会处理下一个请求。一般的服务器不会使用这种方式实现。
2、收到一个请求就新开一个线程去处理任务，主线程返回，继续处理下一个任务，这种为非阻塞
首先纠正一个错误，这并不是非阻塞，它也是阻塞的。相对第一个模型来说，它解决了主线程阻塞的问题，有了一定程度的并发量，但是在每个新开的线程中还是阻塞的。
如果100个人同时访问，将会开100个线程，那1000个人，10000个人呢？频繁开关线程很消耗资源，这样实现的服务器性能依然不高。

除了上面的两种方式，接下来的说说其他更好的方式：
3、类似2的模型，但是不是每次收到请求就开一个新的线程，而是使用线程池
如果不了解线程池，你可能会了解数据库连接池，由于频繁创建、关闭数据库连接会消耗资源，所以会用数据库连接池来保存一定数量的连接，如果需要就从连接池里取连接，不需要则放回连接池，不在频繁创建。
线程池也是一样的道理，线程池管理多线程，性能比频繁创建线程高得多。这种方式实现的服务器性能会比2高。不过，它依然是阻塞的。线程池的线程数量通常有限制的，如果所有线程都被阻塞（例如网速慢，或者被人恶意占用连接），那么接下来的请求将会排队等待。

4、基于Java NIO实现的服务器模型
上面说到的几种模型，都是基于BIO（阻塞IO）。而NIO则是非阻塞IO，它是基于IO多路复用技术（例如Reactor模式）实现，只需要一个线程或者少量线程，就可以处理大量请求。
从性能上来说NIO实现的服务器并发性一般大于BIO，所以可以实现高性能的服务器。如果感兴趣，可以学习一些基于NIO的网络编程框架，例如Netty、MINA。
最后，回答一下题主说到的Tomcat。Tomcat运行可以选择BIO或者NIO模型，原理分别对应上面的3和4两种方式。Tomcat默认是BIO方式运行，如果想要换成NIO，可以配置server.xml：

从性能上考虑建议使用NIO。