

## 数据结构

* 最大公约数：辗转相除法、更相减损术
* 最小公倍数=两数乘积/最大公约数
* 排序算法：冒泡、选择、插入、快速、二分、基数
* 线性表：数组、链表、单链表、双向链表、循环链表、栈、队列
* 二叉树、满二叉树、完全二叉树、二叉查找树、平衡二叉树、红黑树、堆
  * 树中的节点的度即有几个分支（子女），总节点数=总分支+1
  * 二叉树：第i层至多有2^(i-1)个节点，深度为k的二叉树至多有2^k-1个节点
  * 满二叉树：深度为k，且有2^k-1个节点，即父节点都有左右节点，等比数列1+2+4+8+...=2^n-1
  * 完全二叉树：每个节点的序号和满二叉树序号对应，即先排满左边，再排满右边，先排满上层，再排满下层.
    * n0+n1+n2 = n，度为0，1，2（度表示有几个子节点）n0是叶子节点
    * n1=0或1
    * n0=n2+1
    * 可得：n0 = （n+1）/2
    * 用一个数组存储树，第i个节点的左右节点分别为2i+1和2i+2，第i个节点的父节点=(i-1)/2。
  * 二叉查找树：也叫二叉排序树、二叉搜索树，左节点比父节点小，右节点比父节点大，子树也满足这个规则
  * 平衡二叉树：左右子树深度相差不超过1，且子树也都是平衡二叉树
  * 红黑树：根节点是黑色，空节点（假设叶子节点存在两个子节点，为空节点 ）是黑色，每个红色节点的两个子节点是黑色，即红色节点不能连续。大致平衡
  * 二叉堆：特殊的完全二叉树，所有父节点比子节点小，顶部是最小值（小顶堆，最小堆。反之为大顶堆）。
    * 假设父节点为n，则左节点为2n+1，右节点为2n+2
    * 构建：将数组按完全二叉树的顺序填入，从最后一个节点（n）的父节点（n/2）开始调整，与左右节点（n、n+1）比较，大于子节点则与较小的子节点交换位置，然后调整父节点索引-1的节点（n/2-1），与左右节点比较，大于子节点则与较小的子节点交换位置，以此类推。相当于将左边的根节点向下调整一次，然后继续向上之前将右边先调整好
    * 插入：将元素放到堆的最右下方，也就是数组的最后，和父节点（i/2）比较，小于则交换位置，不断向上，直到比父节点大
    * 删除：将要删除的节点替换成最后一个节点，然后将该节点与左右节点比较，选择小的交换，不断下移
* 二叉树先序遍历、中序遍历、后序遍历、层序遍历
* 最小生成树：加权图转换为树、权值最小。
  * Prim算法（加点法）：定义数据结构closedge，u中顶点信息和到该顶点的代价（如closedge的第i个元素为（C,5），则表示v中第i个元素到u的最小代价是到u中的C，代价是5）。一个集合v，存放原有的顶点，一个集合u存放已经连接的顶点，一个集合closeedge，和v对应。从一个顶点开始u={A}，选择最小代价边连接，v中顶点移到u中，closedge代价置为0，更新最小代价边信息。
  * Kruskal算法（加边法）：把所有边断开，并排序，看成n个树（结点为1）组成的森林，选择最小的边，连接两个树，合并为一棵树（保证两个点不是同一颗树），用一个二维链表存放所有树，初始n棵树，合并的时候把两个链表合并，直到只有一颗树，或者有n-1条边
* 单链表删除元素，
  * 时间复杂度是O(n)需要知道删除位置的前驱。
  * 可以使用双链表：O(1)
  * 或者将当前位置与后继元素的数据交换，然后删除后继元素：O(1)

* Java中PriorityQueue实现了小顶堆，每次offer内部会帮我们自动调整，使得根元素最小

## 设计模式和uml

* 单例、工厂、策略、状态、代理，mvc，mvp，mvvm，命令、迭代器
* uml：继承（泛化，实线三角）、实现（虚线三角）、组合（对象属性、实心菱形实线箭头）、聚合（对象属性、空心菱形实线箭头、和组合主要是）、依赖（方法参数、虚线箭头）、关联（单向、双向、自关联）
* **泛化** **=** **实现** **>** **组合** **>** **聚合** **>** **关联** **>** **依赖** 

## Java基础


* Java虚拟机内存
  * 程序计数器：每个线程独立，记录当前执行的指令的地址
  * java栈（虚拟机栈）：栈帧：局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息，一个线程对应一个栈
  * 本地方法栈
  * 堆：对象所在的空间，所有线程共享。包括新生代（Young Gen）、年老代（Tenured Gen，存放生命周期较长的对象，经过多次gc仍然存活）。新生代包括Edan和两块Survivor
  * 方法区：持久代（Permanent），存放类信息、静态变量、静态方法、常量等
* Java GC
* java线程wait等方法
* java线程进程间通信
* java object方法
* java动态代理（反射、Proxy.newInstance()）、代理模式和装饰者模式、AOP
* 控制反转IoC
* java集合

## Android

* 组件化架构

* 打包过程：源码---->java字节码（.class文件）---->虚拟机字节码（dex文件）---->签名---->apk

* 四大组件、生命周期、启动方式

* Activity启动流程（ams，ActivityManageSevice，控制Activity生命周期，ActivityThread.main，程序入口，执行Looper.loop();通过事件来驱动程序）

* java虚拟机：基于栈

* Dalvik：基于寄存器

* ART和Dalvik
  * Dalvik虚拟机：运行时将字节码解释为机器码执行（JIT技术，just in time，即时编译）
  * ART（Android4.4）：安装时转换成机器语言（AOT，Ahead of TIme），优化内存回收算法，多种算法组合

* IPC

* Handler

* Serializable和Parcelable：将对象转换成字节数组

  * Serializable使用反射，将对象序列化存储到本地，按照序列化协议，生成的序列化对象包括header等信息
  * Parcelable通过Parcel对象将数据打包写入共享内存，其他进程可以通过Parcel从共享内存中读出字节流，性能更好
  * 使用transient关键字修饰的变量无法被序列化
  * 使用static修饰的变量无法被序列化（static修饰之后变量和类绑定在一起，而序列化是序列化对象）

* Litepal：使用orm关系映射

* 缓存策略：

  * 一级缓存：使用LruCache类，内部使用LinkedHashMap存储数据，采用 LRU（least recently use算法，最近最久未使用算法，使用链表，如果命中就放到最前面，插入的时候如果满了把最后面的移除，放到最前面需要删除中间的元素）

* 数据持久化

* 定时执行

  ```
  Timer timer = new Timer();
  timer.schedule(new TimerTask(),1000,10000);//延时1s，每隔10s执行一次
  ```

  ```java
  mHandler.postDelayed(new Runnable(
      public void run(){
          mHandler.sendMessage(msg);
          mHandler.postDelayed(this,1000);//循环
      }),1000);//延时1s执行
  mHandler.sendMessageDelayed(msg,1000);
  Handler mHandler = new Handler(){
      public void run(){
          mHandler.sendMessageDelay(msg,1000);
      }
  };
  ```

