注解都在ParameterHandler内定义
ServiceMethod内传入注解的Converter
@Field等注解的Converter只能是Converter<T,String>将泛型转换为String类型
@Body和@Part可以传入Converter<T,RequestBody>，将泛型转换为RequestBody类型

Converter分三种:
Converter<T,RequestBody>
Converter<ResponseBody,T>
Converter<T,String>

设置了格式工厂后(可以设置多个工厂，一个工厂包含多个Converter)
1.在Retrofit类里定义方法，循环判断判断是否存在能将泛型转换为RequestBody类型的转换工厂，并返回Converter<T,RequestBody>
2.在ServiceMethod类里取得各个Converter，根据注解类型设置应用不同的Converter
3.ParameterHandler内已经定义了转换器类型，@Body和@Part注解能使用Converter<T,RequestBody>转换器，其他的注解不行



如Gson格式工厂，包含了GsonResponseBodyConverter和GsonRequestBodyConverter转换器
GsonRequestBodyConverter继承于Converter<T,RequestBody>，因此能将泛型转换为RequestBody并且设置RequestBody的ContentType为application/json
如果请求体有@Body注解，则将转换器应用于该注解的参数
如使用@Field注解，则转换器为Convert<T,String>,ContentType为application/x-www-form-urlencoded,不应用Gson转换工厂将contentType修改，即使修改header让contentType变为json也没用


虽然@Part可以传入Converter<T,RequestBody>，但是在RequestBuilder里面已经提前加了判断，如果是@MutiPart或者@FormEncoded，则使用RequestBody的已有的子类FormBody和MutipartBody来创建RequestBody，而两个子类已经定义好了ContentType，因此Gson转换器设置ContentType无效