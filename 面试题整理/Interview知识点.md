## Java基础(数据结构算法)	

### 理论基础

java关键字、保留字

1. 接口是什么？如何理解面向接口编程这个思想？

   * 一种语法
   * 对逻辑进行抽象
   * 多态：同一个行为具有多个不同表现形式或形态的能力。
   * 对外隐藏细节，而不涉及任何具体的实现细节

2. 抽象类（abstract class）和接口（interface）有什么异同，使用场景的差异


| **参数**           | **抽象类**                                                   | **接口**                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现     | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现.java8可以使用默认接口方法，用default声明 |
| 实现               | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器             | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符         | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。     |
| main方法           | 抽象方法可以有main方法并且我们可以运行它                     | 接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法） |
| 多继承             | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度               | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法         | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |


### 引用及内存

1. 内存泄露，内存溢出与内存抖动的区别

   * 内存泄漏：程序在申请内存后，无法释放已申请的内存空间，memory leak会最终会导致out of memory！

   * 内存抖动：是指在短时间内有大量的对象被创建或者被回收的现象，内存抖动出现原因主要是频繁（很重要）在循环里创建对象。
   * 内存溢出：内存溢出就是你要求分配的内存超出了系统能给你的。分配的内存不足以放下数据项序列,称为。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢

2. 请描述下Java中软引用和弱引用的区别

   * 强引用（普通的引用）>软引用（内存不足时被回收）>弱引用（除了弱引用外没有其他的引用则会被回收）>虚引用（相当于没有引用，要与引用队列配合使用）
   * 虚引用：它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了
   * 如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为`虚可达（phantom reachable）`对象。当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，虚引用必须和引用队列一起使用。
   * 如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。
   * 与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。

3. 如果需实现一个图片缓存的库，用哪种引用比较好

   * 软引用
   * LruCache：最近最少未使用：移除最近未被命中的
   * LFU：最近最不常用：移除一段时间内命中次数最少的

4. 如果要实现一个检测内存泄漏的库，用哪种引用比较好？

   * 弱引用：调用gc，如果弱引用不为空，则表示还有其他地方引用了

5. Java内存模型是怎么样的，GC机制原理. 几种回收机制的介绍（标记清除，标记压缩，分代回收）

   * 回收对象：引用计数法、可达性分析法

   * 在Java语言中，可作为GC Roots的对象包括下面几种：
     - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
     - 方法区中类静态属性引用的对象。
     - 方法区中常量引用的对象。
     - 本地方法栈中JNI（即一般说的Native方法）引用的对象。
   * JDK7中：常量池从方法区移到了堆中。JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池。使用intern方法会将string对象引用加到常量池中，内存中只保留一份，防止重复创建string对象
   * 垃圾收集算法：
     * 标记-清除（Mark-Sweep）算法：分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
     * 复制（copy）算法：它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉
     * 标记-整理（标记-压缩：Mark-Compact）算法：标记。让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
     * 分代收集算法：新生代（回收频繁，使用复制）、老年代（回收不频繁，使用标记-压缩）、永久代（不回收）。
       * 新生代、老年代在堆中
       * 永久代是hotspot对方法区规范的一种实现。在java8中，使用元空间实现方法区
   * GC类型：
     * minor gc:回收新生代（新生代空间不足）
     * major gc:回收年老代（年老代空间不足，或对新生代分配担保不足）
     * full gc:回收所有

### 类加载机制

#### 类的加载过程有了解过吗?双亲委托？

* 加载：将字节码读取到JVM内存中，生成class对象
* 连接：将Java类的二进制代码合并到JVM的运行状态之中。
  * 验证：确保加载的类信息符合JVM规范，没有安全方面的问题。
  * 准备：正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。
  * 解析：虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。
* 初始化：初始化类，静态代码块。当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。
* 使用
* 卸载
* 双亲委托：自顶向下加载。避免重复加载，当父亲已经加载了该类的时候，就没有必要 `ClassLoader`再加载一次。防止自定义的类覆盖系统类
* java：Bootstrap ClassLoader-Extension ClassLoader-Application ClassLoader
* Android：BootClassLoader-PathClassLoader（已安装apk）-DexClassLoader（可以加载未安装apk、dex、jar等）

#### java程序初始化顺序

1. 父类的静态变量
2. 父类的静态代码块
3. 子类的静态变量
4. 子类的静态代码块
5. 父类的非静态变量
6. 父类的非静态代码块
7. 父类的构造方法
8. 子类的非静态变量
9. 子类的非静态代码块
10. 子类的构造方法

### 泛型：

定义：把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型

为什么需要：早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全

好处：

- 代码更加简洁【不用强制转换】
- 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
- 可读性和稳定性【在编写集合的时候，就限定了类型】

1. 泛型作用于编译期还是运行期，为什么？

   * 编译期，只在编译期报错，在运行时不会报错
   * 在运行的时候能够通过反射添加其他类型的值。原因：编译时会发生类型擦除，即编译后不存在泛型，会转换成Object类型，或者extend的类型，可以反编译字节码查看
   * 如果构建 ArrayList 实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。

2. 泛型的类型擦除有了解过吗，简单介绍下。

3. 泛型的上下边界作用是什么？遵循什么样的原则（PECS，Producer Extends Consumer Super）

   * 通配符：？，不确定类型的时候

   * 通配符上限：？ extends A
   * 通配符下限：？super B
   * 如果要从集合中读取类型T的数据，并且**不能写入**，可以使用 ? extends 通配符；(Producer Extends)
     * 编译器只知道它是父类A的子类，不确定具体是哪个子类，所以往集合中写入子类，会出错。但是知道他是父类A的子类，因此可以读出A对象，最终会擦除为A类
   * 如果要从集合中写入类型T的数据，并且**不需要读取**，可以使用 ? super 通配符；(Consumer Super)
     * 编译器知道他是子类B的超类，可以写入B对象或B类的子类对象。但是编译器不知道是B类的哪个超类，因此不能写入其他超类型。最终会擦除为Object对象。读取的时候只能返回Object对象，不知道具体是哪个类
   * 如果既要存又要取，那么就不要使用任何通配符。

### 多线程

1. 如何实现一个有周期性操作的后台线程？比如每过1小时上传一次Log信息到服务器。

   * WokrManager

   * Timer和TimerTask
   * 有一种线程，它是后面运行的，它的任务是为其他线程提供服务，这种线程被称为“后台”线程，又称为“守护线程”或“精灵线程”。JVM的垃圾回收线程就是典型的后台线程。后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡，调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程，所有的前台线程都死亡时，后台线程随之死亡。当整个虚拟机中只剩下后台线程时，程序就没有继续运行的必要了，虚拟机也就退出了。

2. 假设界面上有一个开关，可以控制这个后台线程的开启和关闭，可以怎么改进？

3. 通用问题：
   1. 加锁的方式有哪些，差别是什么
      1. Lock和synchronized区别：
         1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
         2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
         3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
         4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
         5. Lock可以提高多个线程进行读操作的效率。
         6. 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
      2. 锁的类型
         1. 公平锁 / 非公平锁（获取锁是否有优先级）：synchronized为非公平锁，Lock可以通过参数设置是否公平
         2. 可重入锁 / 不可重入锁（是否可以嵌套使用）：synchronized和Lock都是可重入锁
         3. 独享锁 （互斥锁 、排他锁）/ 共享锁（该锁是否一次只能被一个线程使用）：共享锁如读锁、独享锁如写锁。synchronized为独享锁
         4. 乐观锁 / 悲观锁（悲观锁每次访问数据都加锁）：synchronized和Lock都是悲观锁、乐观锁实现如CAS（compareAndSet），Atomic包下的类都是乐观锁。
         5. 分段锁：一组数据分段加锁，避免锁住整组数据，如ConcurrentHashMap
         6. 偏向锁 / 轻量级锁 / 重量级锁
         7. 自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
            * 互斥锁和自旋锁：互斥锁会等待进入阻塞状态，自旋锁是一直运行的（减少线程切换、消耗cpu）

   2. 简述volatile的作用，和synchronize的区别，使用场景的区别

      * 同一进程中所有线程共享内存区域，因此定义全局变量可供其他线程访问。多线程访问全局变量时最好声明为volatile
      * volatile能够保证可见性，不能保证原子性，正常情况下内存会拷贝到cpu缓存中，当多个线程运行在不同cpu上的时候对一个变量修改会导致不同步，使用volatile声明之后会直接从内存中读取，不会进行cpu缓存
      * synchronized同步能够保证可见性和原子性，同一时刻只允许一个线程访问资源。

   3. wait和sleep的区别，那join呢
      * sleep：静态方法，使当前线程休眠，阻塞状态
      * wait：是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入锁池准备获得对象锁进入运行状态。  
      * join是Thread的方法：使当前线程等待该线程运行结束。
      * wait会释放锁
      * sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。

   4. 线程有几种状态
      1. 新建状态(New): 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
      2. 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
      3. 运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
      4. 阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
         - 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
         - 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
         - 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
      5. 死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

   5. 同步方式：闭锁、同步屏障、wait、synchronized、阻塞队列
6. NIO和BIO
   
      1. NIO主要涉及Channel、Selector、Buffer
   2. selector.select是阻塞的：NIO 是同步非阻塞 这句话指的是对于一个IO来看，是同步非阻塞，非阻塞的意思是拥有这次IO的线程没有阻塞，而在NIO中实际上是一条线程拥有很多的IO，有任何一个IO有数据 ，selector就被唤醒。假设在这条线程中，当IOA没有数据处于等待时，IOB可能正在被处理，所以这条线程并没有被这个IOA阻塞。Selector实际是指单线程多路复用
   
7. 信号量（Semaphore）：控制多线程（进程）访问共享资源的同步机制
   
   * 信号量S：整型变量，需要初始化值大于0
   
      * P原语：表示减少信号量，该操作必须是原子的。原子减少，然后如果`S < 0`，则阻塞当前线程
      * V原语：表示增加信号量，该操作必须是原子的。原子增加，然后如果`S <= 0`，则唤醒一个阻塞的线程
   * 用途：用于限流（控制可访问共享资源的线程数量）、实现互斥锁（S=1的时候，不可重入锁）
   
8. 同步屏障（CyclicBarrier）：若有多条线程，他们到达屏障时将会被阻塞，只有当所有线程都到达屏障时才能打开屏障，所有线程同时执行，若有这样的需求可以使用同步屏障。此外，当屏障打开的同时还能指定执行的任务。
   
9. 闭锁（CountDownLatch）：若有多条线程，其中一条线程需要等到其他**所有**线程准备完所需的资源后才能运行，这样的情况可以使用闭锁。
   
10. 同步屏障和闭锁的区别
   
      * 闭锁只会阻塞一条线程，目的是为了让该条任务线程满足条件后执行；
      * 而同步屏障会阻塞所有线程，目的是为了让所有线程同时执行（实际上并不会同时执行，而是尽量把线程启动的时间间隔降为最少）。

### 注解：

1. 按运行机制分
   * 源码注解
   * 编译时注解：在class中依然存在，如@Deprecated、butterknife@BindView、编译时aapt生成检查
   * 运行时注解：运行阶段起作用，如@Autowired、retrofit@Post、@Body、@Field等、运行时反射获取
2. 按来源分
   * 普通注解
   * 自定义注解
   * 元注解：@Rentention、@Target、@Documented、@Inherited

### Java动态代理

1.代理模式、静态代理和动态代理、动态代理实现（如果要代理的对象比较多，需要写大量的代理类）

### 数据结构算法

1. 迭代器和for循环
   1. for循环不能修改集合
   2. for循环适合访问顺序结构,可以根据下标快速获取指定元素.而Iterator 适合访问链式结构,因为迭代器是通过next()和Pre()来定位的.可以访问没有顺序的集合.
   3. 迭代器不用考虑集合类内部实现，方便替换数据结构，如List换位Set。
2. 链表和数组各自的优缺点，使用场景分别是？
   * 数组需要申请连续内存空间，大小固定。

   * 数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建的线性表较稳定。
   * 链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表。
3. HashMap和HashTable的区别？

   * Hashtable是早期提供的接口，HashMap是新版JDK提供的接口。 
   * Hashtable继承Dictionary类，HashMap实现Map接口。 
   * Hashtable线程安全，HashMap线程非安全。 
   * Hashtable不允许null值，HashMap允许null值。
   * 容量的初始值和增加方式都不一样：HashMap默认的容量大小是16；增加容量时，每次将容量变为"原始容量x2"。Hashtable默认的容量大小是11；增加容量时，每次将容量变为"原始容量x2 + 1"；
   * 添加key-value时的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法。Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。
4. HashMap的hash值如何计算，各种方式之间的效率问题，如何优化

   * 对key的hashCode做hash操作，与高16位做异或运算
   * 还有平方取中法，除留余数法，伪随机数法
5. HashMap如何扩容?

   * size：大小
   * capality：容量
   * loadFactor：扩容因子（加载因子）默认是0.75，用于衡量map是否满了。和实时加载因子比较size/capality
   * threshold：插入的时候判断size大于threshold开始扩容
   * `threshold = capality * loadFactor`
   * 默认长度16，扩容成2倍
6. 为什么扩容因子是0.75：空间利用率、避免冲突链表过长，减少查询成本。
7. 初始容量声明为10，最终
8. HashMap是否线程安全，线程安全的定义，想要线程安全时怎么办，ConcurrentHashMap实现原理

   * 1.8之前，segment分段锁设计`Segment` + `HashEntry`的方式进行实现
   * 1.8之后，通过Node` + `CAS` + `Synchronized
9. HashMap插入元素是插入到链表的头部还是尾部，为什么，不同jdk版本下处理有什么异同？"

   * 在jdk1.8之前是插入头部的，在jdk1.8中是插入尾部的。
10. HashMap怎么解决hash冲突的？数组+链表+红黑树

   * jdk8以前，出现hash冲突，加入链表中
   * Jdk8中：如果冲突数量小于8，则是以链表方式解决冲突。冲突大于等于8时，就会将冲突的Entry转换为**红黑树进行存储。
   * 单链表遍历时间复杂度是O(n)，红黑树查找时间复杂度为 O(logn)
11. 处理hash冲突方法：
    * 开放定址法：冲突位置往后查询空位置
    * 再hash法：计算新hash
    * 拉链法：冲突位置构造成链表
    * 公共溢出区：冲突之后填入溢出表，使用新表存储冲突元素

## Android基础	

1. 生命周期：

	* A 正常启动 B：A 的 onPause --> B 的 onCreate --> onStart --> onResume --> A 的 onStop
	* B 返回 A：B 的 onPause --> A 的 onRestart --> onStart --> onResume--> B 的 onStop --> onDestroy
	* A 在栈顶，使用 SingleTop 启动 A：A 的 onPause --> onNewIntent --> onResume
	* A 异常情况下生命周期：onPause --> onSaveInstanceState-->onStop -->onDestroy -->onCreate-->onStart--> onRestoreInstanceState -->onResume
	* onCreate的bundle和onRestoreInstanceState的bundle，onCreate可能为空，onRestoreInstanceState一定不为空
2. Handler

   1. 简述Handler的运行过程，即Handler，Looper，Message如何协同工作的，同时收到多个消息时怎么处理怎么分发出去？
      * Message：
        * next
        * what
        * obj
        * target：存储Handler，分发msg给指定Handler处理
      * MessageQueue：存储管理Message，如enqueue，remove，quit等
      * ThreadLocal：线程本地变量。其他线程无法访问，不同线程获取到的值不一样。
      * Looper：
        * MessageQueue，
        * 使用sThreadLocal存储自身，任何地方可以通过静态方法获取当前线程的Looper。
        * Thread：Looper所在线程。Thread.currentThread()
        * prepare()和prepareMainLooper()：初始化。创建Looper和MessageQueue，存入ThreadLocal
        * loop()：无限循环，获取消息，分发消息（message有callback就让callback处理，没有的话就handleMessage处理）
      * Handler：
        * Looper：通过Looper.myLooper()获取，或者通过构造函数传入自定义Looper。
          * 如果是自己创建，需要在子线程中先prepare()、再创建Handler（防止获取不到myLooper抛异常），然后执行loop()
          * 也可以用HandlerThread，避免自己调用prepare和loop方法
        * MessageQueue：通过Looper获取
      * 插入消息的时候做了同步，防止多个线程同时插入消息
   2. 同步消息、异步消息、屏障消息
      * postSyncBarrier发送屏障消息、屏障消息没有target，设置了同步屏障，则无法接收同步消息，只允许异步消息通过
      * 屏障消息的作用：给异步消息更高的优先级，如视图刷新
      * 异步消息：setAsynchronous，该方法是hide的。给系统开了个后门，防止上层业务加入异步消息，导致系统无法优先处理更重要的事情
      * 当ViewRootImpl调用scheduleTraversals进行measure和layout时，会向主线程的Handler添加同步屏障，遍历完成之后移除同步屏障。布局变化会触发requestLayout
   3. post(Runnable)和sendMessage的区别
      * 写法上有区别，效果上没有区别
      * 一个是通过Message的callback处理消息，一个是通过handleMessage处理消息
   4. HandlerThread的原理分析
      * 继承Thread，在run方法中创建了Looper（prepare），并开启循环（loop），Looper可以通过quit退出
   5. ThreadLocal原理：每个线程保存了一个`ThreadLocalMap<ThreadLocal<?>, Object>`，get的时候通过当前线程获取`Thread.currentThread().threadLocalMaps.get(this)`
   6. Handler内存泄漏解决：remove消息、使用静态内部类+弱引用

3. Service
   1. 简述Service与Activity的通讯方式，各自适用场景和优缺点
      1. binder+回调
      2. 广播
      3. eventbus
      4. startservice
      5. 跨进程可以用Messenger
   2. Service中执行耗时操作是否需要使用多线程，为什么？
      1. 运行在主线程：前台服务（创建通知栏）20s超时，后台服务200s
      2. IntentService
   3. bindService和startService的差异，混合使用对Service生命周期的影响

4. 简述Activity的四种launchMode，各自的使用场景有什么区别？

   * Standard
   * SingleTop
   * SingleTask
   * SingleInstance

5. 简述Android触摸事件分发流程，滑动冲突的解决思路是怎样的？

   * `Activity#dispatchTouchEvent->ViewGroup#dispatchTouchEvent->ViewGroup#onInterceptTouchEvent->View#dispatchTouchEvent->View#onTouchEvent->ViewGroup#onTouchEvent->Activity#onTouchEvent`
   * 某个View一旦消费了Down事件，Move和Up也会交给他处理

   * 滑动冲突：父控件和子控件都有滑动功能
     * ViewGroup#onInterceptTouchEvent：父控件拦截
     * ViewGroup#requestDisallowInterceptTouchEvent：禁止父控件拦截

6. Android的IPC机制
   1. AIDL的实现流程，in/out/inout等参数含义
   2. Binder的原理：内存映射. 内存拷贝一次. Binder线程池（服务端运行在binder线程池）等

7. 自定义View
   1. onMeasure. onLayout. onDraw各自的作用分别是？
   2. MeasureSpec中几种测量模式的区别？
   3. 简述实现继承于ViewGroup的自定义的实现过程？

8. SurfaceView和View的区别，在SurfaceView中如何实现局部刷新？

9. 插件化及热修复的原理分析

10. SQLite数据库升级与数据迁移如何处理？

11. 序列化方式：Parelcable、Serializable

12. 打包流程

## 加分项-项目经验

1. 请说下你在大学期间最满意的一个项目
   1. 考察表达能力
   2. 判断项目难易程度
   3. 判断参与度以及负责模块的技术含量
   4. 考察是否有团队协作的经验
   5. 考察解决问题的能力

3. 请简单说下你在项目中使用到的设计模式，或者你平时比较擅长的设计模式
   1. 考察广度，能说出的设计模式的数量，或者有哪些经典书籍
   2. 考察深度，能否针对某几个设计模式有深入认识，如使用场景，优缺点，变种形式等
   3. 考察运用，能否结合项目或实际例子进行解说

4. 对于项目中用到的开源框架，是否有对比类似的开源库，是否有知道其实现原理
   1. 考察研究气质，能说出选择开源库的原因
   2. 考察技术热情，是否能简单说出其实现原理. 流程或者相关的细节

5. 针对项目具体实现细节问，主要为了考察学生解决问题的能力，以及对项目细节的了解
   1. 如果涉及到网络通信，那么就询问是否考虑到数据请求策略. 缓存策略等
   2. 如果涉及到IM应用，那么就询问是否考虑数据一致性. 消息队列等等
   3. 在现有项目实现上，问更进一步的问题，比如数据量增大到多少的处理方式"


## 加分项-计算机网络	
1. 网络七层模型. TCP和UDP区别。

|              | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | :------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

1. TCP在传输数据时，如何保证数据的可靠性
   * 校验和：校验数据是否损坏
   * 序列号：用于检测丢失的分组和冗余的分组
   * 确认应答：接收方告知发送方正确接收分组以及期望的下一个分组，否定确认：接收方通知发送方未被正确接收的分组
   * 超时重传：前一个数据包超时，但能到达，重传之后会存在两个一样的数据包，因此通过编号的方式标记属于重传数据还是新数据
   * 连接管理：三次握手、四次挥手
   * 流量控制
   * 拥塞控制
   * 累积确认：多个数据包，回复一次确认。避免网络充斥大量确认回复报文
   * 选择确认SACK：选项确认字段，一个报文段（多个数据包）使用两个边界确定，选项字段有4个字节，每个边界4位，因此最多可以表示4个已接受的报文段
   * 连续ARQ（Automatic Repeat-Request，*ARQ*）：自动重传请求
2. TCP三次握手，四次挥手：为什么
3. 沾包拆包
 4. 定时器（分组丢失则重传）
 5. 窗口和流水线（用于增加信道的吞吐量）
6. 详解重传机制，超时时间怎么确定
7. TCP的滑动窗口机制
8. 局域网内两台主机，一台主机去ping另一台主机的IP，其过程
9. Android长连接的心跳机制：如何设计心跳时间，考虑哪些因素DHCP租期. NAT超时. 网络切换. 如何保证尽可能大的心跳时间 
10. UDP如何实现丢包重传策略？

## 架构与设计	
1. 简单介绍所负责项目/模块的架构，这个架构的设计思路是怎样的（可以现场在草稿上画图）？为什么这样设计？MVC. MVVM等主流app架构的优劣。
2. 项目中有用到哪些设计模式？模式各自的优点。
3. 为什么使用这个模式，需结合项目中的实际例子阐述。
4. 易混淆设计模式的区别，如：策略与状态模式. 代理与装饰模式，分别适用的场景？
5. 设计模式背后的设计原则有哪些，了解SOLID原则么？怎么理解与运用的？
   * Single Responsibility Principle：单一职责原则
   * Open Closed Principle：开闭原则
   * Liskov Substitution Principle：里氏替换原则
   * Law of Demeter：迪米特法则
   * Interface Segregation Principle：接口隔离原则
   * Dependence Inversion Principle：依赖倒置原则
6. UML类图、时序图
7. Android或者java源码设计模式：观察者、责任链、享元模式（线程池、Message）、装饰者模式（io类）、Builder（dialog）、策略模式（动画）
   1. 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。
8. 请简单说下MVC和MVP的区别，如果在项目中有使用，可以结合项目说
   1. 能说出两种架构的组成部分，以及各自的优缺点
   2. 能说出MVP的优点，以及MVP是如何实现这些优点的
      1. 优点：降低耦合度、模块职责划分明显、利于单元测试、代码复用、隐藏数据、代码灵活性
      2. 缺点：接口多，view变更，接口需要变更
   3. 能够结合Android和项目进行解说。
   4. MVC中的V层、C层是什么、MVP中的V层、P层是什么。
   5. MVVM的View和ViewModel联系：双向绑定。

## 解决问题能力	1. 遇到过最难的问题？解决问题的思路与流程是怎样的？或则是做技术攻关. 技术预研等。

2. 针对遇到的问题细节提问，如：
 1. 调研了哪些方案？
 2. 方案之间的对比情况？
 3. 有没有更优的解法？
 4. 目前实现方案的弊端与不完善的点有哪些。
3. 解决完问题后自己经验的总结与思考，如何提升后续解决同类问题的速度？
4. 有没有形成Blog或者文档记录，如果有，可以要下链接看下内容的深度。

## 编码能力	

由于泄题较为严重，需要自己准备多套手写代码的题目

1. 考察写代码的能力（速度. 格式. 逻辑等）
2. 考察面对突发问题的思考速度以及思考问题的全面性
3. 考察给予提示时的领悟力
4. 题目有多种解法，如：递归. 非递归，进行引导，考擦逻辑思维能力
5. 写完以后让其自己进行自检与问题修复。
6. 注意代码中可能出现的性能问题，时间空间复杂度分别是多少，自己的思考是怎么样的。

## 性能优化	
1. 性能优化有那几个方面？有哪些工具可以使用？
2. 内存. CPU. UI. 卡顿等优化工具，如：AS Profile. Systrace. overdraw. MAT等如何进行分析，结合实际项目的案例阐述。
3. 过度绘制、减少布局层级。
4. 如何预防性能问题？具体工具的检测原理是怎样的，如LeakCanary是如何检测泄漏的？Bugly如何实现异常捕获？View卡顿的原理？
5. 设计一款性能分析的工具，结合自己的经验，你会如何设计。
6. 设计场景看思路，如：列表滚动卡顿. app启动速度慢分析。


## 加分项-源码阅读	
1. 有看过Framework或者开源库的源码么？自己看源码的方式是怎样的，如何快速看源码？
2. 针对某个细节点进行深入问，如：
 1. AMS中ActivityThread的启动流程？
 2. OkHttp的本地缓存设计？
 3. Retrofit中的callAdapter机制？
 4. EventBus的事件如何进行分发，粘性事件的实现。
3. 阅读源码后自己的思考. 总结与运用，结合实际项目例子阐述。
4. 如果让你参考开源库自己设计一个库，思路如何？如：图片加载库. 事件分发库设计。

## 加分项-技术热情
1. 平时如何学习新技术的？最近半年学习的新技术有哪些（不一定Android相关）？
2. 学习之后在项目中如何实践与应用的，举实际的例子，并解释为什么这样用，好处有哪些？
3. 学习之后自己的总结与思考？有写Blog记录或者分享么，文章数量有多少，每月大概能更新几篇文章？有没自己的开源项目或者有没为其他开源项目做过贡献？
4. 未来1-3年的技术规划是怎样的？自己期望往哪些方向发展或者感兴趣？为什么？"



* 自我介绍
* 项目介绍
* 知识点考察
* 开源框架
* 设计模式
* android打包流程
* 组件化插件化
* 未来规划
* 博客
* 技术面：kotlin、python、uml、后端、前端、算法等





版本适配：[官方文档](https://developer.android.com/about/versions/marshmallow/android-6.0-changes?hl=zh-cn)

* 5.1：MaterialDesign
* 6.0：权限，危险权限，权限组。悬浮窗权限跳转到settings特殊申请。移除Apache Http客户端
* 7.0：directBoot、v2签名、org.apache不支持、非公开ndk链接限制
* 8.0：
  * 限制后台应用启动后台服务，需要使用前台服务。
  * 引入通知渠道
  * 部分静态广播无法接收，需要指定Component（不包含开机广播，应用安装广播）
  * 对TYPE_TOAST做了限制
* 9.0：禁止明文传输，非公开sdk使用限制（SDK中的@hide api无法使用反射访问到。AOSP自行添加的framework的jar包无法使用，需要添加白名单，或者系统签名）
* 10.0：限制后台服务启动Activity。除非处于前台或者有`SYSTEM_ALERT_WINDOW`权限等场景
