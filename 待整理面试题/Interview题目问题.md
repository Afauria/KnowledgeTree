## Android基础	

1. kotlin by委托使用场景
2. 两个Activity跳转生命周期、屏幕切换生命周期
3. onNewIntent什么时候被调用
4. onRestoreInstanceState和onCreate区别
5. Handler
   1. 简述Handler的运行过程，即Handler，Looper，Message如何协同工作的，同时收到多个消息时怎么处理怎么分发出去？
   2. 同步消息、异步消息、屏障消息
   3. post(Runnable)和sendMessage的区别
   4. HandlerThread的原理分析
   5. 为什么通过Handler能实现线程的切换？
   6. Handler.post的逻辑在哪个线程执行的，是由Looper所在线程还是Handler所在线程决定的？
   7. Handler构造方法中通过`Looper.myLooper();`是如何获取到当前线程的Looper的？（ThreadLocal）
   8. Android如何保证一个线程最多只能有一个Looper？如何保证只有一个MessageQueue（ThreadLocal）
   9. ThreadLocaly原理：每个线程保存了一个`ThreadLocalMap<ThreadLocal<?>, Object>`，get的时候通过当前线程获取`Thread.currentThread().threadLocalMaps.get(this)`
   10. Handler内存泄漏原因，解决
6. Service
   1. 简述Service与Activity的通讯方式，各自适用场景和优缺点
      1. binder+回调
      2. 广播
      3. eventbus
      4. startservice
      5. 跨进程可以用Messenger
   2. Service中执行耗时操作是否需要使用多线程，为什么？
      1. 运行在主线程：前台服务（创建通知栏）20s超时，后台服务200s
      2. IntentService
   3. bindService和startService的差异，混合使用对Service生命周期的影响
7. 简述Activity的四种launchMode，各自的使用场景有什么区别？
8. 简述Android触摸事件分发流程，滑动冲突的解决思路是怎样的？

   * `Activity#dispatchTouchEvent->ViewGroup#dispatchTouchEvent->ViewGroup#onInterceptTouchEvent->View#dispatchTouchEvent->View#onTouchEvent->ViewGroup#onTouchEvent->Activity#onTouchEvent`
   * 某个View一旦消费了Down事件，Move和Up也会交给他处理

   * 滑动冲突：父控件和子控件都有滑动功能
     * ViewGroup#onInterceptTouchEvent：父控件拦截
     * ViewGroup#requestDisallowInterceptTouchEvent：禁止父控件拦截
9. Android的IPC机制
   1. AIDL的实现流程，in/out/inout等参数含义
   2. Binder的原理：内存映射. 内存拷贝. Binder线程池等
10. 自定义View
   1. onMeasure. onLayout. onDraw各自的作用分别是？
   2. MeasureSpec中几种测量模式的区别
   3. 简述实现继承于ViewGroup的自定义的实现过程
11. android动画有哪几种？区别是什么？
12. SurfaceView和View的区别，在SurfaceView中如何实现局部刷新？
13. 插件化及热修复的原理分析
14. SQLite数据库升级与数据迁移如何处理？


## Java基础(数据结构算法)	

### 理论基础
java关键字、保留字

1. 接口是什么？如何理解面向接口编程这个思想？

   * 一种语法
   * 对逻辑进行抽象
   * 多态：同一个行为具有多个不同表现形式或形态的能力。
   * 对外隐藏细节，而不涉及任何具体的实现细节

2. 抽象类（abstract class）和接口（interface）有什么异同，使用场景的差异


### 引用及内存

1. 内存泄露，内存溢出与内存抖动的区别

   * 内存泄漏：程序在申请内存后，无法释放已申请的内存空间，memory leak会最终会导致out of memory！

   * 内存抖动：是指在短时间内有大量的对象被创建或者被回收的现象，内存抖动出现原因主要是频繁（很重要）在循环里创建对象。
   * 内存溢出：内存溢出就是你要求分配的内存超出了系统能给你的。分配的内存不足以放下数据项序列,称为。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢

2. 请描述下Java中软引用和弱引用的区别

   * 强引用（普通的引用）>软引用（内存不足时被回收）>弱引用（除了弱引用外没有其他的引用则会被回收）>虚引用（相当于没有引用，要与引用队列配合使用）
   * 虚引用：它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了
   * 如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为`虚可达（phantom reachable）`对象。当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，虚引用必须和引用队列一起使用。
   * 如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其finalize方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。
   * 与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。

3. 如果需实现一个图片缓存的库，用哪种引用比较好

   * 软引用
   * LruCache：最近最少未使用：移除最近未被命中的
   * LFU：最近最不常用：移除一段时间内命中次数最少的

4. 如果要实现一个检测内存泄漏的库，用哪种引用比较好？

   * 弱引用：调用gc，如果弱引用不为空，则表示还有其他地方引用了

5. Java内存模型是怎么样的，GC机制原理. 几种回收机制的介绍（标记清除，标记压缩，分代回收）

   * 回收对象：引用计数法、可达性分析法

   * 在Java语言中，可作为GC Roots的对象包括下面几种：
     - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
     - 方法区中类静态属性引用的对象。
     - 方法区中常量引用的对象。
     - 本地方法栈中JNI（即一般说的Native方法）引用的对象。
   * JDK7中：常量池从方法区移到了堆中。JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池。使用intern方法会将string对象引用加到常量池中，内存中只保留一份，防止重复创建string对象
   * 垃圾收集算法：
     * 标记-清除（Mark-Sweep）算法：分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
     * 复制（copy）算法：它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉
     * 标记-整理（标记-压缩：Mark-Compact）算法：标记。让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
     * 分代收集算法：新生代（回收频繁，使用复制）、老年代（回收不频繁，使用标记-压缩）、永久代（不回收）。
       * 新生代、老年代在堆中
       * 永久代是hotspot对方法区规范的一种实现。在java8中，使用元空间实现方法区
   * GC类型：
     * minor gc:回收新生代（新生代空间不足）
     * major gc:回收年老代（年老代空间不足，或对新生代分配担保不足）
     * full gc:回收所有

### 类加载机制

#### 类的加载过程有了解过吗?双亲委托？

* 加载：将字节码读取到JVM内存中，生成class对象
* 连接：将Java类的二进制代码合并到JVM的运行状态之中。
  * 验证：确保加载的类信息符合JVM规范，没有安全方面的问题。
  * 准备：正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。
  * 解析：虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。
* 初始化：初始化类，静态代码块。当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。
* 使用
* 卸载
* 双亲委托：自顶向下加载。避免重复加载，当父亲已经加载了该类的时候，就没有必要 `ClassLoader`再加载一次。防止自定义的类覆盖系统类
* java：Bootstrap ClassLoader-Extension ClassLoader-Application ClassLoader
* Android：BootClassLoader-PathClassLoader（已安装apk）-DexClassLoader（可以加载未安装apk、dex、jar等）

#### java程序初始化顺序

1. 父类的静态变量
2. 父类的静态代码块
3. 子类的静态变量
4. 子类的静态代码块
5. 父类的非静态变量
6. 父类的非静态代码块
7. 父类的构造方法
8. 子类的非静态变量
9. 子类的非静态代码块
10. 子类的构造方法

### 泛型：

定义：把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型

为什么需要泛型：早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全

好处：

- 代码更加简洁【不用强制转换】
- 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
- 可读性和稳定性【在编写集合的时候，就限定了类型】

1. 泛型作用于编译期还是运行期，为什么？

2. 泛型的类型擦除有了解过吗，简单介绍下。

3. 泛型的上下边界作用是什么？遵循什么样的原则（PECS，Producer Extends Consumer Super）


### 多线程
1. 如何实现一个有周期性操作的后台线程？比如每过1小时上传一次Log信息到服务器。
   * Timer和TimerTask
   * 有一种线程，它是后面运行的，它的任务是为其他线程提供服务，这种线程被称为“后台”线程，又称为“守护线程”或“精灵线程”。JVM的垃圾回收线程就是典型的后台线程。后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡，调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程，所有的前台线程都死亡时，后台线程随之死亡。当整个虚拟机中只剩下后台线程时，程序就没有继续运行的必要了，虚拟机也就退出了。

2. 假设界面上有一个开关，可以控制这个后台线程的开启和关闭，可以怎么改进？
3. 通用问题：
   1. 加锁的方式有哪些，差别是什么
      1. Lock和synchronized区别：
         1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
         2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
         3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
         4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
         5. Lock可以提高多个线程进行读操作的效率。
         6. 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
      2. 锁的类型
         1. synchronized是否公平、是否可重入、是否乐观
         2. 互斥锁和自旋锁区别

   2. 简述volatile的作用，和synchronize的区别，使用场景的区别

   3. wait和sleep的区别，那join呢
      * sleep：静态方法，使当前线程休眠，阻塞状态
      * wait：是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入锁池准备获得对象锁进入运行状态。  
      * join是Thread的方法：使当前线程等待该线程运行结束。
      * wait会释放锁
      * sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常  

   4. 线程有几种状态：新建、就绪、运行、阻塞、死亡。什么情况下会进入阻塞状态
      * 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。

      - 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
      - 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

   5. NIO和BIO

      1. NIO主要涉及Channel、Selector、Buffer
      2. selector.select是阻塞的：NIO 是同步非阻塞 这句话指的是对于一个IO来看，是同步非阻塞，非阻塞的意思是拥有这次IO的线程没有阻塞，而在NIO中实际上是一条线程拥有很多的IO，有任何一个IO有数据 ，selector就被唤醒。假设在这条线程中，当IOA没有数据处于等待时，IOB可能正在被处理，所以这条线程并没有被这个IOA阻塞。Selector实际是指单线程多路复用

   6. 信号量（Semaphore）：控制多线程（进程）访问共享资源的同步机制

      * 信号量S：整型变量，需要初始化值大于0

      * P原语：表示减少信号量，该操作必须是原子的。原子减少，然后如果`S < 0`，则阻塞当前线程
      * V原语：表示增加信号量，该操作必须是原子的。原子增加，然后如果`S <= 0`，则唤醒一个阻塞的线程
      * 用途：用于限流（控制可访问共享资源的线程数量）、实现互斥锁（S=1的时候，不可重入锁）

   7. 同步屏障（CyclicBarrier）：若有多条线程，他们到达屏障时将会被阻塞，只有当所有线程都到达屏障时才能打开屏障，所有线程同时执行，若有这样的需求可以使用同步屏障。此外，当屏障打开的同时还能指定执行的任务。

   8. 闭锁（CountDownLatch）：若有多条线程，其中一条线程需要等到其他**所有**线程准备完所需的资源后才能运行，这样的情况可以使用闭锁。

   9. 同步屏障和闭锁的区别

      * 闭锁只会阻塞一条线程，目的是为了让该条任务线程满足条件后执行；
      * 而同步屏障会阻塞所有线程，目的是为了让所有线程同时执行（实际上并不会同时执行，而是尽量把线程启动的时间间隔降为最少）。

### 注解：

1. 按运行机制分
   * 源码注解
   * 编译时注解：在class中依然存在，如@Deprecated、butterknife@BindView、编译时aapt生成检查
   * 运行时注解：运行阶段起作用，如@Autowired、retrofit@Post、@Body、@Field等、运行时反射获取
2. 按来源分
   * 普通注解
   * 自定义注解
   * 元注解：@Rentention、@Target、@Documented、@Inherited

### Java动态代理

1.代理模式、静态代理和动态代理、动态代理实现（避免写大量的代理类）

### 数据结构算法

1. 迭代器和for循环
2. 链表和数组各自的优缺点，使用场景分别是？
3. HashMap和HashTable的区别
4. HashMap的hash值如何计算，各种方式之间的效率问题，如何优化
5. HashMap如何扩容
6. HashMap是否线程安全，线程安全的定义，想要线程安全时怎么办，ConcurrentHashMap实现原理
7. HashMap插入元素是插入到链表的头部还是尾部，为什么，不同jdk版本下处理有什么异同？"
8. HashMap如何解决hash冲突？（jdk1.8前后）

## 加分项-项目经验

1. 请说下你在大学期间最满意的一个项目
   1. 考察表达能力
   2. 判断项目难易程度
   3. 判断参与度以及负责模块的技术含量
   4. 考察是否有团队协作的经验
   5. 考察解决问题的能力

3. 请简单说下你在项目中使用到的设计模式，或者你平时比较擅长的设计模式
   1. 考察广度，能说出的设计模式的数量，或者有哪些经典书籍
   2. 考察深度，能否针对某几个设计模式有深入认识，如使用场景，优缺点，变种形式等
   3. 考察运用，能否结合项目或实际例子进行解说

4. 对于项目中用到的开源框架，是否有对比类似的开源库，是否有知道其实现原理
   1. 考察研究气质，能说出选择开源库的原因
   2. 考察技术热情，是否能简单说出其实现原理. 流程或者相关的细节

5. 针对项目具体实现细节问，主要为了考察学生解决问题的能力，以及对项目细节的了解
   1. 如果涉及到网络通信，那么就询问是否考虑到数据请求策略. 缓存策略等
   2. 如果涉及到IM应用，那么就询问是否考虑数据一致性. 消息队列等等
   3. 在现有项目实现上，问更进一步的问题，比如数据量增大到多少的处理方式"


## 加分项-计算机网络	
1. 网络七层模型. TCP和UDP区别
2. TCP在传输数据时，如何保证数据的可靠性
 3. 校验和（校验数据是否损坏）
 4. 定时器（分组丢失则重传）
 5. 序号（用于检测丢失的分组和冗余的分组）
 6. 确认（接收方告知发送方正确接收分组以及期望的下一个分组）
 7. 否定确认（接收方通知发送方未被正确接收的分组）
 8. 窗口和流水线（用于增加信道的吞吐量）。
9. 详解重传机制，超时时间怎么确定
10. TCP的滑动窗口机制
11. 局域网内两台主机，一台主机去ping另一台主机的IP，其过程
12. Android长连接的心跳机制：如何设计心跳时间，考虑哪些因素DHCP租期. NAT超时. 网络切换. 如何保证尽可能大的心跳时间 
13. UDP如何实现丢包重传策略？

## 架构与设计	
1. 简单介绍所负责项目/模块的架构，这个架构的设计思路是怎样的（可以现场在草稿上画图）？为什么这样设计？MVM. MVVM等主流app架构的优劣。
2. 项目中有用到哪些设计模式？模式各自的优点。
3. 为什么使用这个模式，需结合项目中的实际例子阐述。
4. 易混淆设计模式的区别，如：策略与状态模式. 代理与装饰模式，分别适用的场景
5. 设计模式背后的设计原则有哪些，了解SOLID原则么？怎么理解与运用的？
6. 请简单说下MVC和MVP的区别，如果在项目中有使用，可以结合项目说
   1. 能说出两种架构的组成部分，以及各自的优缺点
   2. 能说出MVP的优点，以及MVP是如何实现这些优点的
      1. 优点：降低耦合度、模块职责划分明显、利于单元测试、代码复用、隐藏数据、代码灵活性
      2. 缺点：接口多，view变更，接口需要变更
   3. 能够结合Android和项目进行解说
   4. MVC中的V层、C层是什么、MVP中的V层、P层是什么
   5. MVVM的View和ViewModel联系：双向绑定
7. Android或者java源码设计模式：观察者、责任链、享元模式（线程池、message）、装饰者模式（io类）
   1. 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

## 解决问题能力	1. 遇到过最难的问题？解决问题的思路与流程是怎样的？或则是做技术攻关. 技术预研等。

2. 针对遇到的问题细节提问，如：
 1. 调研了哪些方案？
 2. 方案之间的对比情况？
 3. 有没有更优的解法？
 4. 目前实现方案的弊端与不完善的点有哪些。
3. 解决完问题后自己经验的总结与思考，如何提升后续解决同类问题的速度？
4. 有没有形成Blog或者文档记录，如果有，可以要下链接看下内容的深度。

## 编码能力	

由于泄题较为严重，需要自己准备多套手写代码的题目

1. 考察写代码的能力（速度. 格式. 逻辑等）
2. 考察面对突发问题的思考速度以及思考问题的全面性
3. 考察给予提示时的领悟力
4. 题目有多种解法，如：递归. 非递归，进行引导，考擦逻辑思维能力
5. 写完以后让其自己进行自检与问题修复。
6. 注意代码中可能出现的性能问题，时间空间复杂度分别是多少，自己的思考是怎么样的。

## 性能优化	
1. 性能优化有那几个方面？有哪些工具可以使用？
2. 内存. CPU. UI. 卡顿等优化工具，如：AS Profile. Systrace. overdraw. MAT等如何进行分析，结合实际项目的案例阐述。
3. 如何预防性能问题？具体工具的检测原理是怎样的，如LeakCanary是如何检测泄漏的？Bugly如何实现异常捕获？View卡顿的原理？
4. 设计一款性能分析的工具，结合自己的经验，你会如何设计。
5. 设计场景看思路，如：列表滚动卡顿. app启动速度慢分析。


## 加分项-源码阅读	
1. 有看过Framework或者开源库的源码么？自己看源码的方式是怎样的，如何快速看源码？
 1. AMS中ActivityThread的启动流程？
 2. OkHttp的本地缓存设计？
 3. Retrofit中的callAdapter机制？
 4. EventBus的事件如何进行分发，粘性事件的实现。
3. 阅读源码后自己的思考. 总结与运用，结合实际项目例子阐述。
4. 如果让你参考开源库自己设计一个库，思路如何？如：图片加载库. 事件分发库设计。

## 加分项-技术热情	
1. 平时如何学习新技术的？最近半年学习的新技术有哪些（不一定Android相关）？
2. 学习之后在项目中如何实践与应用的，举实际的例子，并解释为什么这样用，好处有哪些？
3. 学习之后自己的总结与思考？有写Blog记录或者分享么，文章数量有多少，每月大概能更新几篇文章？有没自己的开源项目或者有没为其他开源项目做过贡献？
4. 未来1-3年的技术规划是怎样的？自己期望往哪些方向发展或者感兴趣？为什么？"



git有用过吗？gitflow有听说过吗

GIT是分布式版本控制系统，其他类似于SVN是集中式版本控制系统。
分布式区别于集中式在于：每个节点的地位都是平等，拥有自己的版本库，在没有网络的情况下，对工作空间内代码的修改可以提交到本地仓库，此时的本地仓库相当于集中式的远程仓库，可以基于本地仓库进行提交、撤销等常规操作，从而方便日常开发。



adb有用过吗？



