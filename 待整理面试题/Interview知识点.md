

## 引用及内存

1. 如果需实现一个图片缓存的库，用哪种引用比较好

   * 软引用
   * LruCache：最近最少未使用：移除最近未被命中的
   * LFU：最近最不常用：移除一段时间内命中次数最少的
2. 如果要实现一个检测内存泄漏的库，用哪种引用比较好？

   * 弱引用：调用gc，如果弱引用不为空，则表示还有其他地方引用了

### 多线程

1. 如何实现一个有周期性操作的后台线程？比如每过1小时上传一次Log信息到服务器。

   * WokrManager

   * Timer和TimerTask
   * 有一种线程，它是后面运行的，它的任务是为其他线程提供服务，这种线程被称为“后台”线程，又称为“守护线程”或“精灵线程”。JVM的垃圾回收线程就是典型的后台线程。后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡，调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程，所有的前台线程都死亡时，后台线程随之死亡。当整个虚拟机中只剩下后台线程时，程序就没有继续运行的必要了，虚拟机也就退出了。
2. 假设界面上有一个开关，可以控制这个后台线程的开启和关闭，可以怎么改进？
3. 通用问题：
   1. 加锁的方式有哪些，差别是什么
      1. Lock和synchronized区别：
         1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
         2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
         3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
         4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
         5. Lock可以提高多个线程进行读操作的效率。
         6. 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
      2. 锁的类型
         1. 公平锁 / 非公平锁（获取锁是否有优先级）：synchronized为非公平锁，Lock可以通过参数设置是否公平
         2. 可重入锁 / 不可重入锁（是否可以嵌套使用）：synchronized和Lock都是可重入锁
         3. 独享锁 （互斥锁 、排他锁）/ 共享锁（该锁是否一次只能被一个线程使用）：共享锁如读锁、独享锁如写锁。synchronized为独享锁
         4. 乐观锁 / 悲观锁（悲观锁每次访问数据都加锁）：synchronized和Lock都是悲观锁、乐观锁实现如CAS（compareAndSet），Atomic包下的类都是乐观锁。
         5. 分段锁：一组数据分段加锁，避免锁住整组数据，如ConcurrentHashMap
         6. 偏向锁 / 轻量级锁 / 重量级锁
         7. 自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
            * 互斥锁和自旋锁：互斥锁会等待进入阻塞状态，自旋锁是一直运行的（减少线程切换、消耗cpu）

   2. 简述volatile的作用，和synchronize的区别，使用场景的区别

      * 同一进程中所有线程共享内存区域，因此定义全局变量可供其他线程访问。多线程访问全局变量时最好声明为volatile
      * volatile能够保证可见性，不能保证原子性，正常情况下内存会拷贝到cpu缓存中，当多个线程运行在不同cpu上的时候对一个变量修改会导致不同步，使用volatile声明之后会直接从内存中读取，不会进行cpu缓存
      * synchronized同步能够保证可见性和原子性，同一时刻只允许一个线程访问资源。

   3. wait和sleep的区别，那join呢
      * sleep：静态方法，使当前线程休眠，阻塞状态
      * wait：是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入锁池准备获得对象锁进入运行状态。  
      * join是Thread的方法：使当前线程等待该线程运行结束。
      * wait会释放锁
      * sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。

   4. 线程有几种状态
      1. 新建状态(New): 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
      2. 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
      3. 运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
      4. 阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
         - 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
         - 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
         - 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
      5. 死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

   5. 同步方式：闭锁、同步屏障、wait、synchronized、阻塞队列
7. 信号量（Semaphore）：控制多线程（进程）访问共享资源的同步机制
   
   * 信号量S：整型变量，需要初始化值大于0
   
      * P原语：表示减少信号量，该操作必须是原子的。原子减少，然后如果`S < 0`，则阻塞当前线程
      * V原语：表示增加信号量，该操作必须是原子的。原子增加，然后如果`S <= 0`，则唤醒一个阻塞的线程
   * 用途：用于限流（控制可访问共享资源的线程数量）、实现互斥锁（S=1的时候，不可重入锁）

### Java动态代理

1. 代理模式、静态代理和动态代理、动态代理实现（如果要代理的对象比较多，需要写大量的代理类）

## Android基础

1. Service
   1. 简述Service与Activity的通讯方式，各自适用场景和优缺点
      1. binder+回调
      2. 广播
      3. eventbus
      4. startservice
      5. 跨进程可以用Messenger
   2. Service中执行耗时操作是否需要使用多线程，为什么？
      1. 运行在主线程：前台服务（创建通知栏）20s超时，后台服务200s
      2. IntentService
   3. bindService和startService的差异，混合使用对Service生命周期的影响
2. Android的IPC机制
   1. AIDL的实现流程，in/out/inout等参数含义
   2. Binder的原理：内存映射. 内存拷贝一次. Binder线程池（服务端运行在binder线程池）等
3. 自定义View
   1. onMeasure. onLayout. onDraw各自的作用分别是？
   2. MeasureSpec中几种测量模式的区别？
   3. 简述实现继承于ViewGroup的自定义的实现过程？
4. SurfaceView和View的区别，在SurfaceView中如何实现局部刷新？
5. 插件化及热修复的原理分析
6. SQLite数据库升级与数据迁移如何处理？
7. 序列化方式：Parelcable、Serializable
8. 打包流程

## 加分项-项目经验

1. 请说下你在大学期间最满意的一个项目
   1. 考察表达能力
   2. 判断项目难易程度
   3. 判断参与度以及负责模块的技术含量
   4. 考察是否有团队协作的经验
   5. 考察解决问题的能力

3. 请简单说下你在项目中使用到的设计模式，或者你平时比较擅长的设计模式
   1. 考察广度，能说出的设计模式的数量，或者有哪些经典书籍
   2. 考察深度，能否针对某几个设计模式有深入认识，如使用场景，优缺点，变种形式等
   3. 考察运用，能否结合项目或实际例子进行解说

4. 对于项目中用到的开源框架，是否有对比类似的开源库，是否有知道其实现原理
   1. 考察研究气质，能说出选择开源库的原因
   2. 考察技术热情，是否能简单说出其实现原理. 流程或者相关的细节

5. 针对项目具体实现细节问，主要为了考察学生解决问题的能力，以及对项目细节的了解
   1. 如果涉及到网络通信，那么就询问是否考虑到数据请求策略. 缓存策略等
   2. 如果涉及到IM应用，那么就询问是否考虑数据一致性. 消息队列等等
   3. 在现有项目实现上，问更进一步的问题，比如数据量增大到多少的处理方式"

## 架构与设计	
1. 简单介绍所负责项目/模块的架构，这个架构的设计思路是怎样的（可以现场在草稿上画图）？为什么这样设计？MVC. MVVM等主流app架构的优劣。
2. 项目中有用到哪些设计模式？模式各自的优点。
3. 为什么使用这个模式，需结合项目中的实际例子阐述。
4. 易混淆设计模式的区别，如：策略与状态模式. 代理与装饰模式，分别适用的场景？
5. 设计模式背后的设计原则有哪些，了解SOLID原则么？怎么理解与运用的？
6. UML类图、时序图
7. Android或者java源码设计模式：观察者、责任链、享元模式（线程池、Message）、装饰者模式（io类）、Builder（dialog）、策略模式（动画）
   1. 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。
8. 请简单说下MVC和MVP的区别，如果在项目中有使用，可以结合项目说
   1. 能说出两种架构的组成部分，以及各自的优缺点
   2. 能说出MVP的优点，以及MVP是如何实现这些优点的
      1. 优点：降低耦合度、模块职责划分明显、利于单元测试、代码复用、隐藏数据、代码灵活性
      2. 缺点：接口多，view变更，接口需要变更
   3. 能够结合Android和项目进行解说。
   4. MVC中的V层、C层是什么、MVP中的V层、P层是什么。
   5. MVVM的View和ViewModel联系：双向绑定。

## 解决问题能力	1. 遇到过最难的问题？解决问题的思路与流程是怎样的？或则是做技术攻关. 技术预研等。

2. 针对遇到的问题细节提问，如：
 1. 调研了哪些方案？
 2. 方案之间的对比情况？
 3. 有没有更优的解法？
 4. 目前实现方案的弊端与不完善的点有哪些。
3. 解决完问题后自己经验的总结与思考，如何提升后续解决同类问题的速度？
4. 有没有形成Blog或者文档记录，如果有，可以要下链接看下内容的深度。

## 编码能力	

由于泄题较为严重，需要自己准备多套手写代码的题目

1. 考察写代码的能力（速度. 格式. 逻辑等）
2. 考察面对突发问题的思考速度以及思考问题的全面性
3. 考察给予提示时的领悟力
4. 题目有多种解法，如：递归. 非递归，进行引导，考擦逻辑思维能力
5. 写完以后让其自己进行自检与问题修复。
6. 注意代码中可能出现的性能问题，时间空间复杂度分别是多少，自己的思考是怎么样的。

## 性能优化	
1. 性能优化有那几个方面？有哪些工具可以使用？
2. 内存. CPU. UI. 卡顿等优化工具，如：AS Profile. Systrace. overdraw. MAT等如何进行分析，结合实际项目的案例阐述。
3. 过度绘制、减少布局层级。
4. 如何预防性能问题？具体工具的检测原理是怎样的，如LeakCanary是如何检测泄漏的？Bugly如何实现异常捕获？View卡顿的原理？
5. 设计一款性能分析的工具，结合自己的经验，你会如何设计。
6. 设计场景看思路，如：列表滚动卡顿. app启动速度慢分析。


## 加分项-源码阅读	
1. 有看过Framework或者开源库的源码么？自己看源码的方式是怎样的，如何快速看源码？
2. 针对某个细节点进行深入问，如：
 1. AMS中ActivityThread的启动流程？
 2. OkHttp的本地缓存设计？
 3. Retrofit中的callAdapter机制？
 4. EventBus的事件如何进行分发，粘性事件的实现。
3. 阅读源码后自己的思考. 总结与运用，结合实际项目例子阐述。
4. 如果让你参考开源库自己设计一个库，思路如何？如：图片加载库. 事件分发库设计。

## 加分项-技术热情
1. 平时如何学习新技术的？最近半年学习的新技术有哪些（不一定Android相关）？
2. 学习之后在项目中如何实践与应用的，举实际的例子，并解释为什么这样用，好处有哪些？
3. 学习之后自己的总结与思考？有写Blog记录或者分享么，文章数量有多少，每月大概能更新几篇文章？有没自己的开源项目或者有没为其他开源项目做过贡献？
4. 未来1-3年的技术规划是怎样的？自己期望往哪些方向发展或者感兴趣？为什么？"



* 自我介绍
* 项目介绍
* 知识点考察
* 开源框架
* 设计模式
* android打包流程
* 组件化插件化
* 未来规划
* 博客
* 技术面：kotlin、python、uml、后端、前端、算法等



