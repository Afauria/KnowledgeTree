编译时多态，运行时多态

## 数据结构

* 最大公约数：辗转相除法
* 最小公倍数=两数乘积/最大公约数
* 排序算法：冒泡、选择、插入、快速、二分、基数
* 线性表：数组、链表、单链表、双向链表、循环链表、栈、队列
* 二叉树、满二叉树、完全二叉树、二叉查找树、平衡二叉树、红黑树、堆
  * 树种的节点的度即有几个分支（子女），总节点数=总分支+1
  * 二叉树：第i层至多有2^(i-1)个节点，深度为k的二叉树至多有2^k-1个节点
  * 满二叉树：深度为k，且有2^k-1个节点，即父节点都有左右节点
  * 完全二叉树：每个节点的序号和满二叉树序号对应，即先排满左边，再排满右边，先排满上层，再排满下层.
    * n0+n1+n2 = n，度为0，1，2（度表示有几个子节点）n0是叶子节点
    * n0=n2+1
    * n1=0或1
    * 可得：n0 = （n+1）/2
  * 二叉查找树：也叫二叉排序树、二叉搜索树，左节点比父节点小，右节点比父节点大，子树也满足这个规则
  * 平衡二叉树：左右子树深度相差不超过1，且子树也都是平衡二叉树
  * 红黑树：根节点是黑色，空节点（假设叶子节点存在两个子节点，为空节点 ）是黑色，每个红色节点的两个子节点是黑色，即红色节点不能连续。大致平衡
  * 堆：特殊的完全二叉树，用一个数组存储树，第i个节点的左右节点分别为2i和2i+1。所有父节点比子节点小（小顶堆，最小堆。反之为大顶堆）。
    * 构建：将数组按完全二叉树的顺序填入，从最后一个节点（n）的父节点（n/2）开始调整，与左右节点（n、n+1）比较，大于则选择较小的交换位置，然后调整父节点索引-1的节点（n/2-1），与左右节点比较，大于则选择小的交换位置，以此类推。相当于将左边的根节点向下调整一次，然后继续向上之前将右边先调整好
    * 插入：将元素放到堆的最右下方，也就是数组的最后，和父节点（i/2）比较，小于则交换位置，不断向上，直到比父节点大
    * 删除：将要删除的节点替换成最后一个节点，然后将该节点与左右节点比较，选择小的交换，不断下移
* 二叉树先序遍历、中序遍历、后序遍历、层序遍历
* 最小生成树：加权图转换为树、权值最小。
  * Prim算法（加点法）：定义数据结构closedge，u中顶点信息和到该顶点的代价（如closedge的第i个元素为（C,5），则表示v中第i个元素到u的最小代价是到u中的C，代价是5）。一个集合v，存放原有的顶点，一个集合u存放已经连接的顶点，一个集合closeedge，和v对应。从一个顶点开始u={A}，选择最小代价边连接，v中顶点移到u中，closedge代价置为0，更新最小代价边信息。
  * Kruskal算法（加边法）：把所有边断开，并排序，看成n个树（结点为1）组成的森林，选择最小的边，连接两个树，合并为一棵树（保证两个点不是同一颗树），用一个二维链表存放所有树，初始n棵树，合并的时候把两个链表合并，直到只有一颗树，或者有n-1条边

## 设计模式和uml

* 单例、工厂、策略、状态、代理，mvc，mvp，mvvm，命令、迭代器
* uml：继承（泛化，实线三角）、实现（虚线三角）、组合（对象属性、实心菱形实线箭头）、聚合（对象属性、空心菱形实线箭头、和组合主要是）、依赖（方法参数、虚线箭头）、关联（单向、双向、自关联）
* **泛化** **=** **实现** **>** **组合** **>** **聚合** **>** **关联** **>** **依赖** 

## Java基础

* 重写和重载
  * 重写：子类对父类方法重新定义，具有相同的方法名，参数，返回类型，若是重写了方法，则要使用父类方法需要使用super，子类访问权限不能比父类严格，子类抛出异常范围不能比父类大（RuntimeException除外）
  * 重载：参数个数、类型不同，返回值可以不同

* 继承时的初始化顺序：
  * 父类的静态变量
  * 父类静态代码块
  * 子类的静态变量
  * 子类的静态代码块
  * 父类的普通变量
  * 父类普通代码块
  * 父类无参构造函数
  * 子类的普通变量
  * 子类普通代码块
  * 子类无参构造函数

* [Object类有哪些方法](https://www.cnblogs.com/NoPeach/p/8460810.html)

  Object是所有类的父类，任何类都默认继承Object。Object类到底实现了哪些方法？

  1．clone方法：保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

  2．getClass方法：final方法，获得运行时类型。

  3．toString方法：该方法用得比较多，一般子类都有覆盖。

  4．finalize方法：该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

  5．equals方法：该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

  6．hashCode方法：该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

  7．wait方法：wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。调用该方法后当前线程进入睡眠状态，直到以下事件发生。

  （1）其他线程调用了该对象的notify方法。

  （2）其他线程调用了该对象的notifyAll方法。

  （3）其他线程调用了interrupt中断该线程。

  （4）时间间隔到了。

  此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

  8．notify方法：该方法唤醒在该对象上等待的某个线程。

  9．notifyAll方法：该方法唤醒在该对象上等待的所有线程。


* Java虚拟机内存
  * 程序计数器：每个线程独立，记录当前执行的指令的地址
  * java栈（虚拟机栈）：栈帧：局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息，一个线程对应一个栈
  * 本地方法栈
  * 堆：对象所在的空间，所有线程共享。包括新生代（Young Gen）、年老代（Tenured Gen，存放生命周期较长的对象，经过多次gc仍然存活）。新生代包括Edan和两块Survivor
  * 方法区：持久代（Permanent），存放类信息、静态变量、静态方法、常量等

* Java GC
  * 执行时期：不可控，手动调用`System.gc()`，建议执行GC。
    `minor gc`:回收新生代（新生代空间不足）
    `major gc`:回收年老代（年老代空间不足，或对新生代分配担保不足）
    `full gc`:回收所有
  * 回收哪些对象：没有引用的对象有可能被回收。
    判断：引用计数法（很难解决循环引用问题）、可达性分析法（从GCroots出发搜索，没有引用链的时候证明对象不可达）GCRoots：栈中对象，方法区中静态变量，方法区中常量，本地方法栈（JNI）中的对象
  * 怎么回收：标记-清除收集算法、复制算法（适用于新生代：少量对象存活。）、标记-整理算法（适合老年代：老年代存活率高，复制效率低）、分代收集算法（对不同代使用不同的算法）
  * GC扫描Edan和SurvivorA，把幸存的对象移到SurvivorB，下次扫描Edan和SurvivorB，幸存的移到SurvivorA，多次之后还幸存的移到Tenured。客户端新生代和年老代是1:2，服务端是1:8，Edan和Survivor是32:1:1，不同算法有不同的分配比例

* finalize方法，只会执行一次，在GC将要回收之前能够自救一次

* 引用：强引用（普通的引用）>软引用（内存不足时被回收）>弱引用（除了弱引用外没有其他的引用则会被回收）>虚引用（相当于没有引用，要与引用队列配合使用）

* java线程wait等方法

* java线程进程间通信

* java object方法

* java动态代理（反射、Proxy.newInstance()）、代理模式和装饰者模式、AOP

* 控制反转IoC

* java集合

* | 1    | **AbstractCollection**  实现了大部分的集合接口。             |
  | ---- | ------------------------------------------------------------ |
  | 2    | **AbstractList**  继承于AbstractCollection 并且实现了大部分List接口。 |
  | 3    | **AbstractSequentialList**  继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。 |
  | 4    | LinkedList 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：`Listlist=Collections.synchronizedList(newLinkedList(...));`LinkedList 查找效率低。 |
  | 5    | ArrayList 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。 |
  | 6    | **AbstractSet**  继承于AbstractCollection 并且实现了大部分Set接口。 |
  | 7    | HashSet 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。 |
  | 8    | LinkedHashSet 具有可预知迭代顺序的 `Set` 接口的哈希表和链接列表实现。 |
  | 9    | TreeSet 该类实现了Set接口，可以实现排序等功能。              |
  | 10   | **AbstractMap**  实现了大部分的Map接口。                     |
  | 11   | HashMap  HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 |
  | 12   | TreeMap  继承了AbstractMap，并且使用一颗树。                 |
  | 13   | WeakHashMap  继承AbstractMap类，使用弱密钥的哈希表。         |
  | 14   | LinkedHashMap  继承于HashMap，使用元素的自然顺序对元素进行排序. |
  | 15   | IdentityHashMap  继承AbstractMap类，比较文档时使用引用相等。 |

## Android

* 组件化架构

* 打包过程：源码---->java字节码（.class文件）---->虚拟机字节码（dex文件）---->签名---->apk

* 四大组件、生命周期

* Activity四种启动方式
  * standard
  * SingleTop栈顶复用
  * SingleTask栈内复用，将上面的activity销毁
  * SingleInstance新建Task，若已存在则唤醒

* Activity启动流程（ams，ActivityManageSevice，控制Activity生命周期，ActivityThread.main，程序入口，执行Looper.loop();通过事件来驱动程序）

* java虚拟机：基于栈

* Dalvik：基于寄存器

* ART和Dalvik
  * Dalvik虚拟机：运行时将字节码解释为机器码执行（JIT技术，just in time，即时编译）
  * ART（Android4.4）：安装时转换成机器语言（AOT，Ahead of TIme），优化内存回收算法，多种算法组合

* Service Binder机制，Service实现onBind抽象方法，返回一个IBinder对象，binder可以调用getService方法返回服务。bindService方法启动服务，传入一个ServiceConnection接口对象，当服务启动成功后回调onServiceConnected（解绑的时候回调onServiceDisConnected方法），传入IBinder对象，通过getService可以获取到服务，如果是使用Messenger进行线程间通信的话，可以new Messenger(IBinder)创建Messenger对象，然后调用Messenger的send方法发送消息，Messenger是夹在Service和Binder之间的，对Binder进行了封装

* IPC

* Handler

* Serializable和Parcelable：将对象转换成字节数组

  * Serializable使用反射，将对象序列化存储到本地，按照序列化协议，生成的序列化对象包括header等信息
  * Parcelable通过Parcel对象将数据打包写入共享内存，其他进程可以通过Parcel从共享内存中读出字节流，性能更好
  * 使用transient关键字修饰的变量无法被序列化
  * 使用static修饰的变量无法被序列化（static修饰之后变量和类绑定在一起，而序列化是序列化对象）

* Litepal：使用orm关系映射

* 缓存策略：

  * 一级缓存：使用LruCache类，内部使用LinkedHashMap存储数据，采用 LRU（least recently use算法，最近最久未使用算法，使用链表，如果命中就放到最前面，插入的时候如果满了把最后面的移除，放到最前面需要删除中间的元素），单链表删除元素，时间复杂度是O(n)需要知道删除位置的前驱。可以使用双链表：O(1)，或者将当前位置与后继元素的数据交换，然后删除后继元素：O(1)

* 数据持久化

* 定时执行

  ```
  Timer timer = new Timer();
  timer.schedule(new TimerTask(),1000,10000);//延时1s，每隔10s执行一次
  ```

  ```java
  mHandler.postDelayed(new Runnable(
      public void run(){
          mHandler.sendMessage(msg);
          mHandler.postDelayed(this,1000);//循环
      }),1000);//延时1s执行
  mHandler.sendMessageDelayed(msg,1000);
  Handler mHandler = new Handler(){
      public void run(){
          mHandler.sendMessageDelay(msg,1000);
      }
  };
  ```

