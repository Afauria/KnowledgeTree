---
layout: post
title: java基础笔记（占坑）
date: 2018-12-21
description: 平常写代码的时候很多细节没有注意，就是凭感觉和习惯，理论很少去记，因此记录下来作为复习和回顾
categories: Java
tags: 
- Java
---

# 基本数据类型和包装类

## 8种基本数据类型

* 字符型：char（实际是一个16位无符号整数）
* 布尔型：boolean
* 数值型：
  * 整型：byte、short、int、long
  * 浮点型：float（单精度）、double（双精度）

> String不是基本数据类型，是引用类型

实际上，Java中还存在另外一种基本类型`void`，它也有对应的包装类`java.lang.Void`，不过我们无法直接对它们进行操作。

## 存储大小

| 基本数据类型（内置类型） | 对应的包装类型 | 大小             |
| ------------------------ | -------------- | ---------------- |
| char                     | Character      | 2字节            |
| boolean                  | Boolean        | 1个字节或4个字节 |
| byte                     | Byte           | 1个字节          |
| short                    | Short          | 2个字节          |
| int                      | Integer        | 4个字节          |
| long                     | Long           | 8个字节          |
| float                    | Float          | 4字节            |
| double                   | Double         | 8字节            |

1个字节=8位。以int为例：取值范围为`-2^31`到`2^31-1`，可以使用`Integer.MIN_VALUE`和`Integer.MAX_VALUE`获取最小值和最大值。使用`Integer.SIZE`获取int类型位数

## boolean占1或4个字节？

boolean类型理论上只需要1bit空间，但是计算机处理数据的最小单位是1个字节，实际存储的空间是：用1个字节的最低位存储，其他7位用0填补

位（bit）是计算机存储的最小单位，字节是计算机处理数据的最小单位，1字节=8位

> 《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。这样我们可以得出boolean类型**单独使用是4个字节**，在**数组中又是1个字节**。
>
> 使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），具有高效存取的特点。

## 数据超出范围？

如果是字面量（直接量）超出int的取值范围，会出现编译错误，如下：

```java
int a = 2147483648;  //int范围为-2147483648 到 2147483647
```

如果是计算结果溢出，不会抛异常，也没有任何提示。因此计算的时候**需要注意数据溢出**的问题。如下：

```java
System.out.println(Integer.MAX_VALUE + 1);  //输出-2147483648
```

## 为什么需要基本数据类型？

> 对象比较消耗资源：`new`一个对象是存储在堆里的，通过栈中的引用来使用这些对象；对于经常用到的类型，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。

## 为什么需要包装类型？

> Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。例如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。
>
> 为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

## char类型

char类型实际上是一个16位无符号整数（16位Unicode字符），**存储的是对应字符编码**。如字符a实际值为97，字符A实际值为65，字符0实际值为48

> Java字符类型采用Unicode字符集编码（定长字符集），所有字符都是16位表示。
>
> 范围是'\u0000'到'\uffff'，即0到65535

字符字面量包含在单引号中，对不方便输出的字符，可以采用转义字符`\`表示。如`\n`、`\'`、`\"`等

赋值方式：

1. 使用字符赋值
2. 使用16进制整数赋值
3. 使用十进制整数赋值

```java
char c1 = '中';
char c2 = '\u4e2d';
char c3 = 20013;
System.out.println(c1);  //输出中
System.out.println(c2);  //输出中
System.out.println(c3);  //输出中
```



## 类型间转换

1. 隐式类型转换：小类型可以自动转为大类型，发生在赋值的时候，如果右侧是表达式，会先计算表达式，再进行隐式类型转换。
2. 大类型转到小类型需要强制转换，否则可能会造成精度损失，提示编译错误。除非使用强制转换
3. 表达式运算的时候涉及多种数据类型，会自动向较大类型转换
4. byte、char实际上都是整数类型，计算的时候会转为int进行计算

```java

//byte和char参与运算
byte m = 97;
char n = 97;
System.out.println(m); //97
System.out.println(n); //a
System.out.println(m + n); //194
```

# 自动装箱/拆箱

装箱（boxing）：将基本类型转换成对应的包装类型。拆箱（unboxing）则反过来

* 在Java SE5之前，手动装箱：`Integer i = new Integer(10);`
* 在Java SE5中，提供了自动装箱、拆箱功能

自动装箱、拆箱原理：编译时使用包装类的`valueOf()`和`xxxValue()`方法进行拆装箱

注：

1. 如果包装类型是`null`，拆箱`null.intValue()`会发生NPE
2. 循环中大量拆装箱操作会浪费很多资源

举例：

```java
public static void main(String[]args){
  Integer i = 10;  //自动装箱
  int b = i;     //自动拆箱
}
```

将上述代码反编译后得到

```java
public static void main(String[]args){
  Integer a = Integer.valueOf(10); //装箱
  int b = a.intValue(); //拆箱
}
```

## 常见场景

可以使用`javac`编译之后`javap -c`查看汇编指令。也可以通过工具（如`jd-gui`）反编译查看代码

```java
//基本数据类型放入集合类
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i ++){
    li.add(i);
}
```

```java
//包装类型与基本数据类型比较
//理论上==是比较对象地址，这里实现了拆箱
Integer a=1;
System.out.println(a==1?"等于":"不等于");//等于
Boolean bool=false;
System.out.println(bool?"真":"假");//真
```

```java
//包装类型的运算
Integer i = 10;
Integer j = 20;
System.out.println(i+j);
```

```java
//三目运算符使用，当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。
boolean flag = true;
Integer i = 0;
int j = 1;
int k = flag ? i : j;//这里对i进行拆箱，如果是null，会发生NPE，拆箱：i.intValue();
```

```java
//函数参数和返回值
//自动拆箱
public int getNum1(Integer num) {
 return num;
}
//自动装箱
public Integer getNum2(int num) {
 return num;
}
```

## 装箱缓存

Java5对自动装箱提供了**缓存机制**，对常用范围内的包装对象进行缓存和重用，避免频繁创建对象，节省内存、提高性能。

**注：**

1. 只适用于自动装箱，使用构造函数主动创建对象不适用
2. 除了int之外，也有`ByteCache、ShortCache、LongCache、CharacterCache`缓存对应类型的对象
3. byte、short、int、long范围是-128到127，Character范围是0到127

原理：上面提到自动装箱原理是使用`valueOf()`方法返回包装类。

1. 查看`valueOf()`源码，内部使用一个`cache`数组进行缓存，数组中存在会返回同一个对象

```java
public static Integer valueOf(int i) {
  if (i >= IntegerCache.low && i <= IntegerCache.high)
    return IntegerCache.cache[i + (-IntegerCache.low)];  //数组缓存对象
  return new Integer(i);
}
```

2. 查看`IntegerCache`源码：类初始化的时候循环创建对象，存入数组

```java
private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
}
```

如下示例：

使用`javac Main.java`编译，使用`java Main`运行

```java
public class Main {
	public static void main(String[] args) {
		Integer a = 127;
		Integer b = 127;
		System.out.println(a == b);  //输出true
		Integer c = 128;
		Integer d = 128;
		System.out.println(c == d);  //输出false
        //只适用于自动装箱
		Integer e = new Integer(127);
		Integer f = new Integer(127);
		System.out.println(e == f); //输出false
	}
}
```



# 常见问题

1. `System.out.println(5 / 10 * 10);` 输出结果为0，而不是5

2. 有long类型数据参与运算，结果才是long类型，由于是先计算右侧表达式，因此还未进行隐式类型转换。

```java
//隐式类型转换：小类型可以自动转为大类型
long m = 100;
System.out.println(m);
//有long类型数据参与运算，结果才是long类型
long h = Integer.MAX_VALUE + 1;
long i = Integer.MAX_VALUE + 1L;
System.out.println(h); //输出-2147483648
System.out.println(i); //输出2147483648
```

3. 表达式出现多种数据类型，自动向大类型转换

```java
double persent1 = 80 / 100; //结果为0.0，先计算右侧表达式，再进行隐式类型转换
double persent2 = 80.0 / 100; //结果为0.8，右边表达式有double型直接量参与， 运算结果为double型
```

4. long类型数据赋值给int，会出现编译错误，提示“不兼容的类型: 从long转换到int可能会有损失”。除非强制转换

```java
//编译错误，提示“不兼容的类型: 从long转换到int可能会有损失”，除非强制转换
// int j = 1L;
int j = (int) 1L;
```

5. 浮点数默认是double类型，如果要使用float，需要加`f`或`F`后缀。double也可加`d`或`D`表示double类型

```java
//编译错误：提示“不兼容的类型: 从double转换到float可能会有损失”
float k = 3.14;
```

6. 浮点运算会出现舍入误差，需要使用`BigDecimal`

```java
System.out.println(3.0-2.9);  //输出0.10000000000000009
System.out.println(3.0f-2.9f);  //输出0.099999905
```



 **1、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?**

 答：对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

 对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

 

 **2、char类型变量能不能储存一个中文的汉子，为什么？**

char类型变量是用来储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的，还有一种特殊情况就是某个生僻字没有包含在unicode编码字符集中，那么就char类型就不能存储该生僻字。

 

 **3、Integer和int的区别**

int是java的8种内置的原始数据类型。Java为每个原始类型都提供了一个封装类，Integer就是int的封装类。

int变量的默认值为0，Integer变量的默认值为null，这一点说明Integer可以区分出未赋值和值为0的区别，比如说一名学生没来参加考试，另一名学生参加考试全答错了，那么第一名考生的成绩应该是null，第二名考生的成绩应该是0分。关于这一点Integer应用很大的。Integer类内提供了一些关于整数操作的一些方法，例如上文用到的表示整数的最大值和最小值。

 

 **4、switch语句能否作用在byte上，能否作用在long上，能否作用在string上？**

 byte的存储范围小于int，可以向int类型进行隐式转换，所以switch可以作用在byte上

 long的存储范围大于int，不能向int进行隐式转换，只能强制转换，所以switch不可以作用在long上

 string在1.7版本之前不可以，1.7版本之后switch就可以作用在string上了

 

**5.是否存在 x>x+1?为什么？**

 这就是临界值，当x=最大值 时； 再加1（根据二进制运算+1）就超过了它的临界值，刚好会是它最小值。 

举个例子吧，byte 8位， -128 ~ 127  

127 二进制： 0111 1111

1 二进制 ：   0000 0001

相加结果：   1000 0000

byte 8位 **有符号**，  1000 0000 刚好 为 -128



float a = 0.125f; double b = 0.125d; System.out.println((a - b) == 0.0); 代码的输出结果是什么？
A. true
B. false

**double c = 0.8; double d = 0.7; double e = 0.6; 那么 c-d 与 d-e 是否相等？**
A. true
B. false



**System.out.println(1.0 / 0); 的结果是什么？**


A. 抛出异常
B. Infinity
C. NaN



**System.out.println(0.0 / 0.0); 的结果是什么？**


A. 抛出异常
B. Infinity
C. NaN
D. 1.0



**>> 和 >>> 的区别是？**


A. 任何整数没有区别
B. 负整数一定没有区别
C. 浮点数可以 >> 运算，但是不可以 >>> 运算
D. 正整数一定没有区别



**某个类有两个重载方法：void f(String s) 和 void f(Integer i)，那么 f(null) 的会调用哪个方法？**


A. 前者
B. 后者
C. 随机调用
D. 编译出错

**某个类有两个重载方法：void g(double d) 和 void g(Integer i)，那么 g(1) 的会调用哪个方法？**


A. 前者
B. 后者
C. 随机调用
D. 编译出错



**String a = null; switch(a) 匹配 case 中的哪一项？**


A. null
B. "null"
C. 不与任何东西匹配，但不抛出异常
D. 直接抛出异常



**<String, T, Alibaba> String get(String string, T t) { return string; } 此方法：**


A. 编译错误，从左往右第一个 String 处
B. 编译错误，T 处
C. 编译错误，Alibaba 处
D. 编译正确



**HashMap 初始容量 10000 即 new HashMap(10000)，当往里 put 10000 个元素时，需要 resize 几次（初始化的那次不算）？**


A. 1 次
B. 2 次
C. 3 次
D. 0 次

# 结语

案例汇总

```java
public class Main {
	public static void main(String[] args) {
		//缓存范围-128到127
		Integer a = 127;
		Integer b = 127;
		System.out.println(a == b);  //输出true
		Integer c = 128;
		Integer d = 128;
		System.out.println(c == d);  //输出false
        //缓存只适用于自动装箱
		Integer e = new Integer(127);
		Integer f = new Integer(127);
		System.out.println(e == f); //输出false
		System.out.println(Integer.MAX_VALUE + 1); //输出-2147483648
		//编译错误，提示“过大的整数”
		// int g = 2147483648;
		System.out.println(5 / 10 * 10); //输出0，而不是5

		//隐式类型转换：小类型可以自动转为大类型
		//有long类型数据参与运算，结果才是long类型
		long h = Integer.MAX_VALUE + 1;
		long i = Integer.MAX_VALUE + 1L;
		System.out.println(h); //输出-2147483648
		System.out.println(i); //输出2147483648
		//编译错误，提示“不兼容的类型: 从long转换到int可能会有损失”，除非强制转换
		// int j = 1L;
		int j = (int) 1L;
		
		//浮点数默认为double类型，如果要使用float，需要加f或F后缀。
		//编译错误：提示“不兼容的类型: 从double转换到float可能会有损失”
		//float k = 3.14;
		float l = 3.14f;
		//舍入误差
		System.out.println(3.0-2.9);  //输出0.10000000000000009
		System.out.println(3.0f-2.9f);  //输出0.099999905

		//byte、char实际上都是整数类型，计算的时候会转为int进行计算
		byte m = 97;
		char n = 97;
		System.out.println(m); //97
		System.out.println(n); //a
		System.out.println(m + n); //194

		//表达式出现多种数据类型，自动向大类型转换
		double o = 80 / 100; //结果为0.0，先计算右侧表达式，再进行隐式类型转换
		double p = 80.0 / 100; //结果为0.8，右边表达式有double型直接量参与， 运算结果为double型

		char c1 = '中';
		char c2 = '\u4e2d';
		char c3 = 20013;
		System.out.println(c1);
		System.out.println(c2);
		System.out.println(c3);
		
	}
}
```

带有中文注释，编译的时候需要指定UTF-8编码`javac -encoding UTF-8 Main.java`，再使用`java Main`执行



参考文章：[什么是Java中的自动拆装箱](https://blog.csdn.net/wufaliang003/article/details/82347077)

https://hollischuang.github.io/toBeTopJavaer/#/basics/java-basic/integer-scope

https://www.jianshu.com/p/2adb8fe74987